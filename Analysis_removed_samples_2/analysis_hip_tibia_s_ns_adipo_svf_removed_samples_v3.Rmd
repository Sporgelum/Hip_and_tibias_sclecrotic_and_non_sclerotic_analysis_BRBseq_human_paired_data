---
title: 'Lea Hip & Tibia BRBseq July 2024 '
output:
  html_document:
    df_print: paged
---

```{r}
setwd("/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/")
```



Path to the data: ***Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq***


# --- Import libraries
```{r}
#library(BiocManager)
rm(list = ls(all.names = TRUE))
gc()
#.libPaths("/home/mbotos/R/x86_64-pc-linux-gnu-library/4.2/")
.libPaths("/home/mbotos/CLUSTER/RLibs/")

# BiocManager::install(c("dorothea"),force=TRUE,ask = TRUE)
# library(dorothea)

library(dplyr)
library(tidyr)
unloadNamespace("edgeR")
library(edgeR)
library(ggplot2)
library(ggrepel)
library(svglite)
```



# --- Read tables
```{r}
matrix_counts_tibia <- read.table(file ="/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/brbseq-nf-pipeline/results/AMP0211/count_matrix/L270524LF01_01.read.counts.sampleIDs.detailed.txt",sep = "\t",header = TRUE)
head(matrix_counts_tibia)
tail(matrix_counts_tibia)
dim(matrix_counts_tibia)
head(matrix_counts_tibia)
```
```{r}
matrix_counts_hip <- read.table(file ="/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/brbseq-nf-pipeline/results/AMP0211/count_matrix/L270524LF02_01.read.counts.sampleIDs.detailed.txt",sep = "\t",header = TRUE)
head(matrix_counts_hip)
tail(matrix_counts_hip)
dim(matrix_counts_hip)
head(matrix_counts_hip)
```


```{r}
ncol(matrix_counts_tibia)
colnames(matrix_counts_tibia)
```

```{r}
ncol(matrix_counts_hip)
colnames(matrix_counts_hip)
```


```{r}
# Remove the last column
# New version do not need to be removed, Uknown columns is not there anymore...
#the Gene_id or Gene_name which are in the position 1 and 2

#matrix_counts <- matrix_counts[,-ncol(matrix_counts)]

# Remove the last 5 rows
matrix_counts_tibia <- matrix_counts_tibia[1:(nrow(matrix_counts_tibia)-5),]
head(matrix_counts_tibia)
tail(matrix_counts_tibia)
dim(matrix_counts_tibia)
colnames(matrix_counts_tibia)[3:ncol(matrix_counts_tibia)]
```
```{r}
# Remove the last 5 rows
matrix_counts_hip <- matrix_counts_hip[1:(nrow(matrix_counts_hip)-5),]
head(matrix_counts_hip)
tail(matrix_counts_hip)
dim(matrix_counts_hip)
colnames(matrix_counts_hip)[3:ncol(matrix_counts_hip)]
```


# --- Add metadata table from the xlsx file
```{r}
#install.packages("readxl")
md <- readxl::read_xlsx(path ="/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/metadata/sample_info_minimal_SIT.xlsx")
md$sampleID
```

```{r}

# Use mutate to format the sample IDs
md_df <- md %>% 
  dplyr::mutate(sampleID = gsub(" ", ".", sampleID)) %>%
  dplyr::mutate(sampleID = paste0("X", sampleID))

# Display the data frame with formatted sample IDs
print(md_df)
```



```{r}
md
md_df

```


# Generate more columns for the data to plot
```{r}
md_df$sampleID
# Split the sampleID column
md_df_split <- strsplit(as.character(md_df$sampleID), "_", fixed = TRUE)

# Create new columns
md_df$sample_number <- sapply(md_df_split, function(x) x[1])
md_df$tissue <- sapply(md_df_split, function(x) x[2])
#md_df$health_status <- sapply(md_df_split, function(x) paste(x[3], x[4], sep = "_"))
md_df$health_status <- sapply(md_df_split, function(x) paste(x[3], sep = "_"))
md_df$tissue_celltype <- sapply(md_df_split, function(x) paste(x[4], sep = "_"))
md_df$tissue_celltype_lowercase <- tolower(md_df$tissue_celltype)
md_df$tissue_lowercase <- tolower(md_df$tissue)
md_df$full_name <- md_df$sampleID


# View the dataframe
md_df

```

# Plot number of tibia vs hip
```{r}
# Summarize the data
summary_df <- md_df %>%
  group_by(tissue_lowercase) %>%
  summarise(n = n()) %>%
  ungroup()

# Plot with individual bar colors and labels
ggplot(data = summary_df, aes(x = tissue_lowercase, y = n, fill = tissue_lowercase)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = n), vjust = -0.5, size = 3.5) +
  labs(
    title = "Number of Samples per Tissue",
    x = "Tissue",
    y = "Number of Samples"
  ) +
    theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",  # hide legend if each bar is already labeled
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    panel.background = element_blank(),   # Remove background
    axis.line = element_line(colour = "black")  # Add axis lines
    
  ) +
  scale_y_continuous(breaks = seq(0, max(summary_df$n), by = 10))

```

# Plot number of tibia vs hip
```{r}
# Summarize the data
summary_df <- md_df %>%
  group_by(tissue_lowercase) %>%
  summarise(n = n()) %>%
  ungroup()

# Plot with individual bar colors and labels
ggplot(data = summary_df, aes(x = tissue_lowercase, y = n, fill = tissue_lowercase)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = n), vjust = -0.5, size = 3.5) +
  labs(
    title = "Number of Samples per Tissue",
    x = "Tissue",
    y = "Number of Samples"
  ) +
    theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none",  # hide legend if each bar is already labeled
    panel.grid.major = element_blank(),  # Remove major grid lines
    panel.grid.minor = element_blank(),  # Remove minor grid lines
    panel.background = element_blank(),   # Remove background
    axis.line = element_line(colour = "black")  # Add axis lines
    
  ) +
  scale_y_continuous(breaks = seq(0, max(summary_df$n), by = 10))

```
# Add gender, age and BMI to metadata.
```{r}
agbmi_df <- readxl::read_xlsx(path ="/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/metadata/age-gender-BRBseq_2.xlsx")
agbmi_df

# Add X infront of the sample ID and close non sclerotic with non.sclerotic.

agbmi_df <- agbmi_df |>  
  dplyr::mutate(`Sample ID` = gsub(" ", ".", `Sample ID`)) |> 
  dplyr::mutate(`Sample ID` = paste0("X", `Sample ID`))
agbmi_df

md_df <- merge(x = md_df,y = agbmi_df,by.x = "sampleID",by.y = "Sample ID")

```

# HCLUST, check samples
## Clustering can be used to see samples that have a weird pattern.
```{r, fig.height=5,fig.width=9}
# per tibia
# per hip
# per bone
# done on normalized samples! --> so go first through EDGER 

TTM_samples <- function(matrix_of_counts,metadata,gene_info){
  # Build DGE list and normalize
  message("Building DGEList and normalizing using TMM.\n")
  y <- DGEList(counts = matrix_of_counts, group = metadata$Group, genes = gene_info)
  y_norm <- calcNormFactors(y, method = "TMM")
  y_normalized_corrected <- cpm(y_norm, normalized.lib.sizes = TRUE)
  logcpm <- cpm(y_norm, log=TRUE, prior.count=1)
  rownames(y_normalized_corrected) <- y$genes$genes
  list_of_results <- list(
    raw_matrix_of_counts=matrix_of_counts,
    normalized_counts = y_normalized_corrected,
    transformation_vector = y_norm,
    gene_info = gene_info,
    logcpm=logcpm)
  message("Dooone")
  return(list_of_results)
  
}
```


```{r, fig.height=5,fig.width=9}
tmm_hip_counts <- TTM_samples(matrix_of_counts = matrix_counts_hip[,3:ncol(matrix_counts_hip)],metadata = md_df |>
                                filter(tissue=="Hip") |>
                                select(health_status,full_name,sampleID,barcode,tissue,health_status,
                                       tissue_celltype,tissue_celltype_lowercase,'Plate ID',Row.y,Column.y,Species.y,'Tissue/cell type',Age,Gender,BMI),
                              gene_info = matrix_counts_hip$Gene_name)


sampleTree <- hclust(dist(t(tmm_hip_counts$logcpm)), method = "average") #Clustering samples based on distance 

#Setting the graphical parameters
par(cex = 0.6);
par(mar = c(0,4,2,0))

#Plotting the cluster dendrogram
plot(sampleTree, main = "Sample clustering to detect outliers hip", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
abline(h = 170000, col = "red");
```

```{r, fig.height=5,fig.width=9}
tmm_tibia_counts <- TTM_samples(matrix_of_counts = matrix_counts_tibia[,3:ncol(matrix_counts_tibia)],metadata = md_df |>
                                filter(tissue=="tibia") |>
                                select(health_status,full_name,sampleID,barcode,tissue,health_status,
                                       tissue_celltype,tissue_celltype_lowercase,'Plate ID',Row.y,Column.y,Species.y,'Tissue/cell type',Age,Gender,BMI),
                              gene_info = matrix_counts_tibia$Gene_name)


sampleTree <- hclust(dist(t(tmm_tibia_counts$logcpm)), method = "average") #Clustering samples based on distance 

#Setting the graphical parameters
par(cex = 0.6);
par(mar = c(0,4,2,0))

#Plotting the cluster dendrogram
plot(sampleTree, main = "Sample clustering to detect outliers tibia", sub="", xlab="", cex.lab = 1.5,
cex.axis = 1.5, cex.main = 2)
abline(h = 150000, col = "red");

```



# Orientation of Data
## Transposed Data (samples as rows, genes as columns)

m <- prcomp(t(matrix_counts_hip[,3:ncol(matrix_counts_hip)]), scale. = TRUE, center = TRUE)
Input Matrix: After transposing, each row represents a sample, and each column represents a gene.
Interpretation: PCA will identify principal components based on the variance among samples across different genes.
Results: The principal components will describe the variation between the samples. Each principal component (PC) is a linear combination of the gene expression values.


## Non-Transposed Data (genes as rows, samples as columns)

m <- prcomp(matrix_counts_hip[,3:ncol(matrix_counts_hip)], scale. = TRUE, center = TRUE)
Input Matrix: Without transposing, each row represents a gene, and each column represents a sample.
Interpretation: PCA will identify principal components based on the variance among genes across different samples.
Results: The principal components will describe the variation between the genes. Each principal component (PC) is a linear combination of the sample values.


# Choosing the Right Approach
The choice of whether to transpose the data or not depends on what you want to analyze:

## Analyzing Variation Between Samples: If your goal is to analyze how samples (conditions) vary based on gene expression profiles, you should transpose the data so that each row represents a sample. This will provide principal components that describe the differences between samples.
m <- prcomp(t(matrix_counts_hip[,3:ncol(matrix_counts_hip)]), scale. = TRUE, center = TRUE)


## Analyzing Variation Between Genes: If your goal is to analyze how genes vary across different samples, you should not transpose the data, keeping genes as rows and samples as columns. This will provide principal components that describe the differences between genes.
m <- prcomp(matrix_counts_hip[,3:ncol(matrix_counts_hip)], scale. = TRUE, center = TRUE)



# Clean rows that have gene expression for all the samples < 3 counts.
```{r}
# If no results of DEG obtained, we reduce stringency, so lower the number.

ncol(matrix_counts_hip)
dim(matrix_counts_hip[,3:ncol(matrix_counts_hip)][rowSums(matrix_counts_hip[,3:ncol(matrix_counts_hip)]) >= 30,])
dim(matrix_counts_tibia[,3:ncol(matrix_counts_tibia)][rowSums(matrix_counts_tibia[,3:ncol(matrix_counts_tibia)]) >= 30,])

```


```{r}
# row_sums <- rowSums(matrix_counts_hip[, 3:ncol(matrix_counts_hip)])
# matrix_counts_hip_filtered <- matrix_counts_hip[row_sums >= 30,]
# matrix_counts_hip_filtered
```




#Function for PCA, removing empty genes counts and empty columns if trnasposed and clean duplicated
```{r}
run_pca_structuring <- function(matrix_data, md_df = NULL, transpose = FALSE, filter_empty_samples_counts = 30) {
  # Check input
  if (!is.data.frame(matrix_data) && !is.matrix(matrix_data)) {
    stop("matrix_data must be a data frame or matrix.")
  }
  
  data_matrix_raw <- matrix_data
  
  # Remove duplications and set up matrix
  data_matrix_raw <- data_matrix_raw[!duplicated(data_matrix_raw$Gene_name) & data_matrix_raw$Gene_name != "",]
  rownames(data_matrix_raw) <- data_matrix_raw$Gene_name
  
  # Extract numeric data (adjust column range as needed)
  data_matrix_raw <- data_matrix_raw[, 3:ncol(data_matrix_raw)]
  
  # Filter low-count genes
  row_sums <- rowSums(data_matrix_raw)
  data_matrix_filtered <- data_matrix_raw[row_sums >= filter_empty_samples_counts, ]
  
  # Ensure numeric matrix
  data_matrix_filtered <- as.matrix(data_matrix_filtered)
  if (!is.numeric(data_matrix_filtered)) {
    stop("PCA input must be numeric.")
  }
  
  # Run PCA based on transpose parameter
  if (transpose) {
    # Samples as rows, genes as columns
    if (ncol(data_matrix_filtered) < 2 || nrow(data_matrix_filtered) < 2) {
      stop("Not enough data points for PCA after transpose.")
    }
    m <- prcomp(t(data_matrix_filtered), scale. = TRUE, center = TRUE)
    # For transpose=TRUE, rotation contains sample loadings
    m_df <- as.data.frame(m$rotation)
  } else {
    # Genes as rows, samples as columns  
    if (nrow(data_matrix_filtered) < 2 || ncol(data_matrix_filtered) < 2) {
      stop("Not enough data points for PCA.")
    }
    m <- prcomp(data_matrix_filtered, scale. = TRUE, center = TRUE)
    # For transpose=FALSE, x contains sample scores
    m_df <- as.data.frame(m$rotation)
  }
  
  m_df$sample_id <- rownames(m_df)
  
  # Merge with metadata if provide and the data matrix was transposed else do not merge
  #  if (transpose && !is.null(md_df)) {
  if (transpose) {
    m_merged <- m_df
  } else {
    m_merged <- merge(x = m_df, y = md_df, by.x = "sample_id", by.y = "full_name", all.x = TRUE)
  }
  
  # Calculate variance explained
  percent_var <- m$sdev^2 / sum(m$sdev^2)
  
  return(list(
    matrix_raw = data_matrix_filtered,
    matrix_pca = m_merged,
    percentVar_obj = percent_var
  ))
}
```

# Check the duplicated such as SNORA,RGS5, SIGLEC5,SPATA13,U3,U2,U8,SNORD,YRNA..

```{r}
#Genes variability, typically biology difference across samples is stronger.. so it is also difficult to catch...
#Genes variability, typically biology difference across samples is stronger.. so it is also difficult to catch...
m_pca_tibia <- run_pca_structuring(matrix_data = matrix_counts_tibia,transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)
m_pca_hip <- run_pca_structuring(matrix_data = matrix_counts_hip,transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)


```

### If this crash, make sure that the matrix is a matrix.
```{r}
# # If the list is a list of equal-length numeric vectors:
# data_matrix_fixed <- as.data.frame(data_matrix_filtered)
# 
# # Or try to coerce directly to a matrix:
# data_matrix_fixed <- as.matrix(data_matrix_filtered)
# 
# str(data_matrix_filtered)
# is.matrix(data_matrix_filtered)

```


# Plot the PCA function
```{r}
require("ggplot2")
plot_the_pca <- function(pca_df, 
                         color_var = NULL, 
                         shape_var = NULL,
                        #  colors = NULL,        
                        #  shapes = NULL,        
                         pc_x = "PC1", 
                         pc_y = "PC2",
                         title = "PCA Plot", 
                         subtitle = "",
                         color_palette = NULL,
                         shape_palette = NULL,
                         alpha = 0.7,
                         point_size = 4,
                         text_var = NULL,
                         text_size = 3,
                         percentVar_obj,
                         add_jitter = FALSE,
                         jitter_width = 0.01,
                         jitter_height = 0.01) {
  
  require(ggplot2)

  # # Use aliases if provided
  # if (!is.null(colors)) color_var <- colors
  # if (!is.null(shapes)) shape_var <- shapes

  # Input validation
  if (!pc_x %in% colnames(pca_df)) stop(paste("PC component", pc_x, "not found in data"))
  if (!pc_y %in% colnames(pca_df)) stop(paste("PC component", pc_y, "not found in data"))
  if (!is.null(color_var) && !color_var %in% colnames(pca_df)) stop(paste("Color variable", color_var, "not found in data"))
  if (!is.null(shape_var) && !shape_var %in% colnames(pca_df)) stop(paste("Shape variable", shape_var, "not found in data"))

  # Extract PC numbers
  pc_x_num <- as.numeric(gsub("PC", "", pc_x))
  pc_y_num <- as.numeric(gsub("PC", "", pc_y))

  if (pc_x_num > length(percentVar_obj) || pc_y_num > length(percentVar_obj)) {
    stop("PC number exceeds available components")
  }

  # Dynamically build aesthetics
  aes_args <- list(x = sym(pc_x), y = sym(pc_y))
  if (!is.null(color_var)) aes_args$colour <- sym(color_var)
  if (!is.null(shape_var)) aes_args$shape <- sym(shape_var)

  p <- ggplot(pca_df, do.call(aes, aes_args))

  if (add_jitter) {
    p <- p + geom_jitter(size = point_size, alpha = alpha,
                         width = jitter_width, height = jitter_height)
  } else {
    p <- p + geom_point(size = point_size, alpha = alpha)
  }

  # Add text labels if requested
  if (!is.null(text_var) && text_var %in% colnames(pca_df)) {
    p <- p + geom_text(aes(label = .data[[text_var]]), 
                       color = "black", 
                       size = text_size,
                       vjust = -0.5)
  }

  # Axis labels
  var_x <- round(percentVar_obj[pc_x_num] * 100, 2)
  var_y <- round(percentVar_obj[pc_y_num] * 100, 2)

  p <- p + labs(
    title = title,
    subtitle = subtitle,
    x = paste0(pc_x, ": ", var_x, "% variance"),
    y = paste0(pc_y, ": ", var_y, "% variance")
  )

  if (!is.null(color_var)) {
    p <- p + labs(color = tools::toTitleCase(gsub("_", " ", color_var)))
  }
  if (!is.null(shape_var)) {
    p <- p + labs(shape = tools::toTitleCase(gsub("_", " ", shape_var)))
  }

  if (!is.null(color_var) && !is.null(color_palette)) {
    p <- p + scale_color_manual(values = color_palette)
  }

  if (!is.null(shape_var) && !is.null(shape_palette)) {
    p <- p + scale_shape_manual(values = shape_palette)
  }

  p <- p + theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      panel.border = element_rect(fill = "transparent", color = "black"),
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 10),
      plot.title = element_text(size = 14, face = "bold"),
      plot.subtitle = element_text(size = 12),
      axis.title = element_text(size = 11)
    )

  return(p)
}
```


# --- Raw

# Tibia
```{r,fig.width=6,fig.height=3}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
# Generate the columns in the md_df
plot_the_pca(pca_df = m_pca_tibia$matrix_pca,
             color_var = "tissue_celltype_lowercase",
             shape_var = "health_status",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias SVF and Adipocytes",text_var = "sample_number",
             percentVar_obj = m_pca_tibia$percentVar_obj)


```



# Hip
```{r,fig.width=6,fig.height=3}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
plot_the_pca(pca_df = m_pca_hip$matrix_pca,
             color_var = "tissue_celltype_lowercase",shape_var = "health_status",
             pc_x = "PC1",pc_y = "PC2",
             title = "PCA of RNA-seq Raw Data",subtitle = "Hips SVF and Adipocytes",text_var = "sample_number",
             percentVar_obj = m_pca_hip$percentVar_obj)

```


```{r}
m_pca_tibia_t <- run_pca_structuring(matrix_data = matrix_counts_tibia,transpose = TRUE,filter_empty_samples_counts = 30,md_df = md_df)
m_pca_hip_t <- run_pca_structuring(matrix_data = matrix_counts_hip,transpose = TRUE,filter_empty_samples_counts = 30,md_df = md_df)


```

# Tibia
```{r,fig.width=6,fig.height=3}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
plot_the_pca(pca_df = m_pca_tibia_t$matrix_pca,
             color_var=NULL,shape_var=NULL,
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of Transposed RNA-seq Raw Data", subtitle = "Tibias SVF and Adipocyte Transposed",text_var = "sample_number",
             percentVar_obj = m_pca_tibia_t$percentVar_obj)



```
# Hip
```{r,fig.width=6,fig.height=3}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
plot_the_pca(pca_df = m_pca_hip_t$matrix_pca,
             color_var =  NULL,shape_var = NULL
             ,pc_x = "PC1",pc_y = "PC2",title="PCA of Transposed RNA-seq Raw Data",subtitle = "Hips SVF and Adipocyte Transposed",text_var = "sample_number",
             percentVar_obj = m_pca_hip$percentVar_obj)


```


#############################
#     Tibia Adipocytes      #
#############################
```{r,fig.width=6,fig.height=3}
m_pca_tibia_adipocytes <- run_pca_structuring(matrix_data = matrix_counts_tibia |> dplyr::select("Gene_id","Gene_name",ends_with("adipocyte")),transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)

plot_the_pca(pca_df = m_pca_tibia_adipocytes$matrix_pca,
             color_var =  "health_status",shape_var = "tissue_celltype_lowercase",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias Adipocytes",text_var = "sample_number",
             percentVar_obj = m_pca_tibia_adipocytes$percentVar_obj)



# Issued samples with low number of genes per sample from HTML report
#107 tibia non sclerotic adipocyte
#107 tibia sclerotic adipocyte
##99 tibia sclerotic adipocyte


#80 tibia non sclerotic pellet
#163 tibia sclerotic pellet
```

#############################
#     Tibia SVF/Pellet      #
#############################
```{r,fig.width=6,fig.height=3}
m_pca_tibia_svf <- run_pca_structuring(matrix_data = matrix_counts_tibia |> dplyr::select("Gene_id","Gene_name",ends_with("pellet")),transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)

plot_the_pca(pca_df = m_pca_tibia_svf$matrix_pca,
             color_var =  "health_status",shape_var = "tissue_celltype_lowercase",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias Adipocytes",text_var = "sample_number",
             percentVar_obj = m_pca_tibia_svf$percentVar_obj)




# Issued samples with low number of genes per sample from HTML report

#80 tibia non sclerotic pellet
#163 tibia sclerotic pellet
```

```{r}

```
#############################
#     Hip Adipocytes        #
#############################
```{r,fig.width=6,fig.height=3}
m_pca_hip_adipocytes <- run_pca_structuring(matrix_data = matrix_counts_hip |> dplyr::select("Gene_id","Gene_name",ends_with("adipocyte")),transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)

plot_the_pca(pca_df = m_pca_hip_adipocytes$matrix_pca,
             color_var =  "health_status",shape_var = "tissue_celltype_lowercase",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Hips Adipocytes Transposed",text_var = "sample_number",
             percentVar_obj = m_pca_hip_adipocytes$percentVar_obj)



# Issued samples with low number of genes per sample from HTML report, expected to be also associated with low number of sequencing read per sample...
#74 hip non sclerotic adipocyte
#79 hip non sclerotic adipocyte
#150 hip non sclerotic adipocyte

#74 hip sclerotic adipocyte
#79 hip sclerotic adipocyte

#78 hip non sclerotic adipocyte
#78 hip sclerotic adipocyte

```


#############################
#     Hip SVF/Pellet      #
#############################
```{r,fig.width=6,fig.height=3}
m_pca_hip_pellet <- run_pca_structuring(matrix_data = matrix_counts_hip |> dplyr::select("Gene_id","Gene_name",ends_with("pellet")),transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df)


plot_the_pca(pca_df = m_pca_hip_pellet$matrix_pca,
             color_var =  "health_status",shape_var = "tissue_celltype_lowercase",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Hips Pellet",text_var = "sample_number",
             percentVar_obj = m_pca_hip_pellet$percentVar_obj)

# Issued samples with low number of genes per sample from HTML report

 
#74 Hip non sclerotic pellet
#74 Hip sclerotic pellet
#78 hip non.sclerotic pellet
#78 hip sclerotic pellet
```


```{r}
# Transposed, we can not really plot the sample contribution for all genes... 
m_pca_hip_pellet_t <- run_pca_structuring(matrix_data = matrix_counts_hip |> dplyr::select("Gene_id","Gene_name",ends_with("pellet")),transpose = TRUE,filter_empty_samples_counts = 30,md_df = md_df)


plot_the_pca(pca_df = m_pca_hip_pellet_t$matrix_pca,
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Hips Pellet",text_var = "sample_number",
             percentVar_obj = m_pca_hip_pellet_t$percentVar_obj)

```


```{r}
md_df
```


##########################
# Test of QC for samples #
##########################


## Remove if are away for complexity or number of genes.
Genes here have been filtered for under 30 counts.. in the matrix_raw counts

```{r}
head(m_pca_tibia$matrix_raw)
```
### Plot the number of reads per sample from raw matrix of tibia.
```{r,fig.width=25,fig.height=9}
#matrix_counts_tibia
#m_pca_tibia$matrix_raw

sums_mm = colSums(matrix_counts_tibia[3:ncol(matrix_counts_tibia)])
sums_mm <- data.frame(Column = colnames(matrix_counts_tibia[3:ncol(matrix_counts_tibia)]), Sum = sums_mm)
sums_mm$Column <-tolower(sums_mm$Column)



# Categorize the groups based on the Column names
sums_mm$Group <- ifelse(grepl("tibia_non.sclerotic_adipocyte", sums_mm$Column), "TNSA",
                   ifelse(grepl("tibia_sclerotic_adipocyte", sums_mm$Column), "TSA",
                          ifelse(grepl("tibia_non.sclerotic_pellet", sums_mm$Column), "TNSP", "TSP")))

sums_mm
# Create a custom color palette
color_palette <- c("TNSA" = "#00296b", "TSA" = "#1e91d0", "TNSP" = "#faa819","TSP"="#f37520")
```


```{r,fig.width=29,fig.height=14}
library(ggplot2)
mean_sum <- mean(sums_mm$Sum)
quantiles <- quantile(sums_mm$Sum, probs = c(0.25, 0.75,0.90))

p <- ggplot(sums_mm, aes(x = reorder(Column, Sum), y = Sum, fill = Group)) +
#ggplot(sums_mm, aes(x = Column, y = Sum, fill = Group)) +
  

  geom_bar(stat = "identity") +
  labs(title = "Counts Sums",
       x = "Samples",
       y = "Sum of all counts") +
  scale_fill_manual(values = color_palette) +
  geom_hline(aes(yintercept = mean_sum, color = "Mean"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = quantiles[1], color = "25th Percentile"), linetype = "dotted", linewidth = 1) +
  geom_hline(aes(yintercept = quantiles[2], color = "75th Percentile"), linetype = "dotted", linewidth = 1) +
  geom_hline(aes(yintercept = quantiles[3], color = "90th Percentile"), linetype = "dotted", linewidth = 1) +
  scale_color_manual(values = c("red", "blue", "green","#903498"),
                     breaks = c("Mean", "25th Percentile", "75th Percentile", "90th Percentile"),
                     name = "Statistics") +  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.text.y = element_text(size = 12),
        panel.background = element_blank(),  # Remove panel background
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        )  # Rotate x-axis labels for better visibility

pp <- plotly::ggplotly(p)
pp
```

```{r}
ggplot(sums_mm, aes(x = Group, y = Sum, fill = Group)) +
  geom_boxplot(alpha = 0.6, outlier.shape = NA) +
  #geom_jitter(width = 0.2, size = 2, aes(text = Column)) +
  geom_jitter() +
  scale_fill_manual(values = color_palette) +
  geom_text(aes(label = .data[["Column"]]),
            color = "black",
            size = 2,
            vjust = -0.5)+
  labs(
    title = "Distribution of Read Counts per Group",
    x = "Group",
    y = "Total Counts"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 10)
  ) -> p2

plotly::ggplotly(p2, tooltip = "text")

```
```{r}
ggplot(sums_mm, aes(x = Group, y = Sum, fill = Group)) +
  geom_violin(trim = FALSE, alpha = 0.6) +
  geom_jitter(width = 0.2, size = 2, aes(text = Column)) +
  scale_fill_manual(values = color_palette) +
  labs(
    title = "Read Count Distribution by Group",
    x = "Group",
    y = "Total Counts"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 10)
  ) -> p3

plotly::ggplotly(p3, tooltip = "text")

```


# TIBIA Samples out
```{r}
# X163   TSP
# X99    TSA
# X107   TNSA TSA TNSP
# X80    TNSP TNSA TSP
# X105   TSP TNSP
# X148   TSP
# X104   TSA TSP
# X164   TSA 
# X109   TNSP
# we filter out around same proportions if 25% in TIBIA is around 700k we filtered 407265 and in HIP 25% is 1M in Hip, we filterd 791K
```


```{r}
sums_mm |> dplyr::filter(Sum < 407265)
sums_mm_tibia <- sums_mm |> dplyr::filter(!Sum < 407265)
sums_mm_tibia$Samples <- rownames(sums_mm_tibia)
sums_mm_tibia
```

# Extra filtered from the group out
```{r}
#107 All
#80 All
sums_mm_tibia <- sums_mm_tibia |> dplyr::filter(!Samples %in% c("X107_tibia_sclerotic_pellet",
                                                                "X80_tibia_sclerotic_adipocyte"))


sums_mm_tibia
```


```{r}
# Check samples are removed
samples_to_be_removed <- c("X163_Tibia_sclerotic_pellet",    "X107_Tibia_non.sclerotic_adipocyte",    "X107_Tibia_sclerotic_adipocyte",    "X107_Tibia_non.sclerotic_pellet",    "X107_Tibia_sclerotic_pellet",
                           "X99_Tibia_sclerotic_adipocyte",    "X80_Tibia_non.sclerotic_pellet",    "X80_Tibia_sclerotic_pellet",    "X80_Tibia_non.sclerotic_adipocyte",    "X80_Tibia_sclerotic_adipocyte",
                           "X109_Tibia_non.sclerotic_pellet",    "X148_Tibia_sclerotic_pellet",    "X130_Tibia_sclerotic_pellet",    "X104_Tibia_sclerotic_pellet",    "X104_Tibia_sclerotic_adipocyte",
                           "X105_Tibia_non.sclerotic_pellet",    "X105_Tibia_sclerotic_pellet",    "X109_Tibia_non.sclerotic_pellet",    "X102_tibia_non.sclerotic_pellet",    "X102_tibia_sclerotic_pellet","X102_tibia_non.sclerotic_adipocyte","X148_Tibia_sclerotic_adipocyte")

sums_mm_tibia |> dplyr::filter(Samples %in% samples_to_be_removed)

# Remove samples still in the tibia data. 
sums_mm_tibia <- sums_mm_tibia |> dplyr::filter(!Samples %in% c("X148_Tibia_sclerotic_adipocyte",
                                                                "X130_Tibia_sclerotic_pellet",
                                                                "X102_tibia_non.sclerotic_adipocyte",
                                                                "X102_tibia_sclerotic_adipocyte",
                                                                "X102_tibia_non.sclerotic_pellet",
                                                                "X102_tibia_sclerotic_pellet"))
sums_mm_tibia


```



# HIP

```{r}
head(m_pca_hip$matrix_raw)
```
### Plot the number of reads per sample from raw matrix of tibia.
```{r,fig.width=25,fig.height=9}
#matrix_counts_hip
#m_pca_hip$matrix_raw
sums_mm = colSums(matrix_counts_hip[3:ncol(matrix_counts_hip)])
sums_mm <- data.frame(Column = colnames(matrix_counts_hip[3:ncol(matrix_counts_hip)]), Sum = sums_mm)


sums_mm$Column <-tolower(sums_mm$Column)


# Categorize the groups based on the Column names
sums_mm$Group <- ifelse(grepl("hip_non.sclerotic_adipocyte", sums_mm$Column), "HNSA",
                   ifelse(grepl("hip_sclerotic_adipocyte", sums_mm$Column), "HSA",
                          ifelse(grepl("hip_non.sclerotic_pellet", sums_mm$Column), "HNSP", "HSP")))

sums_mm
# Create a custom color palette
color_palette <- c("HNSA" = "#00296b", "HSA" = "#1e91d0", "HNSP" = "#faa819","HSP"="#f37520")
```


```{r,fig.width=25,fig.height=9}
library(ggplot2)
c <- mean(sums_mm$Sum)
quantiles <- quantile(sums_mm$Sum, probs = c(0.25, 0.75,0.90))

p <- ggplot(sums_mm, aes(x = reorder(Column, Sum), y = Sum, fill = Group)) +
#ggplot(sums_mm, aes(x = Column, y = Sum, fill = Group)) +
  

  geom_bar(stat = "identity") +
  labs(title = "Counts Sums",
       x = "Samples",
       y = "Sum of all counts") +
  scale_fill_manual(values = color_palette) +
  geom_hline(aes(yintercept = mean_sum, color = "Mean"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = quantiles[1], color = "25th Percentile"), linetype = "dotted", size = 1) +
  geom_hline(aes(yintercept = quantiles[2], color = "75th Percentile"), linetype = "dotted", size = 1) +
  geom_hline(aes(yintercept = quantiles[3], color = "90th Percentile"), linetype = "dotted", size = 1) +
  scale_color_manual(values = c("red", "blue", "green","#903498"),
                     breaks = c("Mean", "25th Percentile", "75th Percentile", "90th Percentile"),
                     name = "Statistics") +  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.text.y = element_text(size = 12),
        panel.background = element_blank(),  # Remove panel background
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        )  # Rotate x-axis labels for better visibility

plotly::ggplotly(p)
```
### Boxplots hips samples distribution
```{r}
ggplot(sums_mm, aes(x = Group, y = Sum, fill = Group)) +
  geom_boxplot(alpha = 0.6, outlier.shape = NA) +
  geom_jitter() +#width = 0.2, size = 2, aes(text = Column)) +
  scale_fill_manual(values = color_palette) +
  labs(
    title = "Distribution of Read Counts per Group",
    x = "Group",
    y = "Total Counts"
  ) +
  geom_text(aes(label = .data[["Column"]]),
            color = "black",
            size = 2,
            vjust = -0.5)+
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 10)
  ) -> p2

plotly::ggplotly(p2, tooltip = "text")

```
### Boxplots hips samples distribution
```{r}
ggplot(sums_mm, aes(x = Group, y = Sum, fill = Group)) +
  geom_violin(trim = FALSE, alpha = 0.6) +
  geom_jitter(width = 0.2, size = 2, aes(text = Column)) +
  scale_fill_manual(values = color_palette) +
  labs(
    title = "Read Count Distribution by Group",
    x = "Group",
    y = "Total Counts"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 10)
  ) -> p3

plotly::ggplotly(p3, tooltip = "text")

```


# HIP Samples out
```{r}
#####X78 - 4
#####X74 -4
#####X79 -2 HNSA and HSA
#####X150 HNSA
#####X154 HNSP
# Removed all the samples with less than 791286 counts in Hip.

```

# Filter Samples
```{r}
sums_mm_hip <- sums_mm |> dplyr::filter(!Sum < 791286)
sums_mm |> dplyr::filter(Sum < 791286)
sums_mm_hip$Samples <- rownames(sums_mm_hip)
sums_mm_hip

```
## Clean samples hip
```{r}
samples_to_be_removed_hip <- c("X74_Hip_non.sclerotic_adipocyte",    "X74_Hip_sclerotic_adipocyte",    "X79_Hip_non.sclerotic_adipocyte",    "X79_Hip_sclerotic_adipocyte",    "X150_Hip_non.sclerotic_adipocyte",
                               "X74_Hip_non.sclerotic_pellet",    "X74_Hip_sclerotic_pellet",    "X78_Hip_non.sclerotic_adipocyte",    "X78_Hip_sclerotic_adipocyte",    "X78_Hip_non.sclerotic_pellet",
                               "X78_Hip_sclerotic_pellet",    "X154_Hip_sclerotic_pellet",    "X154_Hip_non.sclerotic_pellet",    "X145_Hip_non.sclerotic_pellet",    "X126_Hip_non.sclerotic_pellet")



sums_mm_hip |> dplyr::filter(Samples %in% samples_to_be_removed_hip)

sums_mm_hip <- sums_mm_hip |> dplyr::filter(!Samples %in% c("X145_Hip_non.sclerotic_pellet",
                                                            "X126_Hip_non.sclerotic_pellet",
                                                            "X154_Hip_sclerotic_pellet"))

sums_mm_hip

```


# Comparisons
### Use the samples cleaned objects

```{r}
sums_mm_tibia
sums_mm_hip 
```

# filter out the samples we removed before
```{r}
sums_mm_tibia
sums_mm_hip
#matrix_counts_tibia
#matrix_counts_hip

# counts and duplicated gene names were removed
m_pca_tibia$matrix_raw_filtered_samples_for_DEG <- m_pca_tibia$matrix_raw[,rownames(sums_mm_tibia)]
m_pca_hip$matrix_raw_filtered_samples_for_DEG <- m_pca_hip$matrix_raw[,rownames(sums_mm_hip)]
#using dplyr
#m_pca_tibia$matrix_raw_filtered_samples_for_DEG <- m_pca_tibia$matrix_raw |>   select(all_of(rownames(sums_mm_tibia)))
```


```{r}
# Merge back the metadata and the selected samples 
md_df_tibia <- merge(x=md_df,y = sums_mm_tibia,by.x="sampleID",by.y="Samples")
md_df_hip <- merge(x=md_df,y = sums_mm_hip,by.x="sampleID",by.y="Samples")

#Check if this samples are present..
md_df_tibia$sampleID[grepl(pattern = "X80",x = md_df_tibia$sampleID)]
md_df_hip$sampleID[grepl(pattern = "X74",x = md_df_hip$sampleID)]
```


#############
### EDGER ###
#############

### LRT: Suitable for complex designs but may not fully account for variability, potentially leading to inflated false positives.
### QLF: Provides robust results by modeling extra variability through quasi-likelihood methods and shrinkage estimators. It yields more accurate p-values and better control over false positives.

# --- Normalize
```{r,fig.width=12,fig.height=6}
#############
#   edgeR   #
#############
#library(data.table)
library(edgeR)
#Run edgeR on the COMBATseq batch corrected data.
message("Builduing the DEG data list for edgeR.")

#.1- Build DGE list and normalize
y = DGEList(counts = m_pca_tibia$matrix_raw_filtered_samples_for_DEG, group = md_df_tibia$Group, genes = rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG))
#perform TMM normalization
message("Normalizing using TMM.\n")
y_norm <- calcNormFactors(object = y,method = "TMM")
y_normalized_corrected <- cpm(y = y_norm,normalized.lib.sizes = TRUE)
logcpm <- cpm(y_norm, log = TRUE, prior.count = 1, normalized.lib.sizes = TRUE)

rownames(y_normalized_corrected) <- y$genes$genes

#y_normalized_corrected_pcas <- prcomp(log2(y_normalized_corrected + 1))
y_normalized_corrected_pcas <- prcomp(logcpm,center = TRUE,scale. = TRUE)


#calculat the PC "%"'s
percentVar_obj <- y_normalized_corrected_pcas$sdev^2/sum(y_normalized_corrected_pcas$sdev^2)
#Save as a df
y_normalized_corrected_pcas_df <- as.data.frame(y_normalized_corrected_pcas[2]$rotation)
y_normalized_corrected_pcas_df <- merge(y_normalized_corrected_pcas_df,md_df_tibia, by.x = "row.names", by.y = "sampleID")
# y_normalized_corrected_pcas_df[,c(1,18)]
message("Done")
message("Plot ready.")


# y_normalized_corrected_pcas_df <- y_normalized_corrected_pcas_df |> dplyr::mutate(Sample2 = sub("^(.*?)\\..*", "\\1", Sample))
# y_normalized_corrected_pcas_df <- y_normalized_corrected_pcas_df |> dplyr::mutate(Sample3 = sub(".*?\\.(.*)", "\\1", Sample))


#colnames(md_df_tibia)
#md_df_tibia$Age <- as.factor(md_df_tibia$Age)
for (column_to_plot in c("Tissue/cell type","Age","health_status","Group","Plate.ID")) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias (Normalized TMM)",subtitle = "TSA TSP TNSA TNSP",text_var = "sample_number",
                     percentVar_obj = percentVar_obj,))
  }

```


# EDGER Normalization function

```{r}
library(edgeR)
library(dplyr)

normalize_and_pca <- function(count_matrix, gene_info, metadata,transpose=FALSE) {
  # Check if inputs are data frames or matrices
  if (!is.data.frame(count_matrix) && !is.matrix(count_matrix)) {
    stop("count_matrix must be a data frame or matrix.")
  # }
  # if (!is.factor(group)) {
  #   stop("group must be a factor.")
  }
  if (!is.vector(gene_info) && !is.list(gene_info)) {
    stop("gene_info must be a vector or list")
  }
  if (!is.data.frame(metadata)) {
    stop("metadata must be a data frame.")
  }
  
  # Build DGE list and normalize
  message("Building DGEList and normalizing using TMM.\n")
  y <- DGEList(counts = count_matrix, group = metadata$Group, genes = gene_info)
  y_norm <- calcNormFactors(y, method = "TMM")
  y_normalized_corrected <- cpm(y_norm, normalized.lib.sizes = TRUE)
  logcpm <- cpm(y_norm, log = TRUE, prior.count = 1, normalized.lib.sizes = TRUE)

  rownames(y_normalized_corrected) <- y$genes$genes
  
  # Perform PCA
  message("Performing PCA.\n")
    # Check transpose
  if (transpose){
    y_normalized_corrected_pcas <- prcomp(t(logcpm), center = TRUE, scale. = TRUE)
  } else {
    y_normalized_corrected_pcas <- prcomp(logcpm, center = TRUE, scale. = TRUE)
  }
  #y_normalized_corrected_pcas <- prcomp(y_normalized_corrected, center = TRUE, scale. = TRUE)
  
  
    
  # Calculate the percentage of variance for each principal component
  percentVar_obj <- y_normalized_corrected_pcas$sdev^2 / sum(y_normalized_corrected_pcas$sdev^2)
  
  # Save PCA results as a data frame
  y_normalized_corrected_pcas_df <- as.data.frame(y_normalized_corrected_pcas[2]$rotation)
  
  # Merge PCA results with metadata
  y_normalized_corrected_pcas_df <- merge(y_normalized_corrected_pcas_df, metadata, by.x = "row.names", by.y = "sampleID")
  
  # # Optionally mutate the sample names
  # y_normalized_corrected_pcas_df <- y_normalized_corrected_pcas_df %>%
  #   mutate(Sample2 = sub("^(.*?)\\..*", "\\1", Row.names),
  #          Sample3 = sub(".*?\\.(.*)", "\\1", Row.names))
  # 
  message("Done")
  message("ready to Plot ")
  
  return(list(
    pca_results = y_normalized_corrected_pcas_df,
    percent_variance = percentVar_obj,
    logcpm=logcpm
    
  ))
}

# Example usage:

results <- normalize_and_pca(
  count_matrix = m_pca_tibia$matrix_raw_filtered_samples_for_DEG,
  gene_info = rownames(m_pca_tibia$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_tibia,
  transpose = FALSE
)

#md_df_tibia$Age <- as.factor(md_df_tibia$Age)
for (column_to_plot in c("Tissue/cell type","Age","health_status","Group", "Plate.ID")) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  if (!(column_to_plot %in% colnames(results$pca_results))) {
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
      color_var = column_to_plot,
      shape_var = "Gender",
      pc_x = "PC1", pc_y = "PC2",
      title = "Tibias (Normalized TMM)",subtitle = "TSA TSP TNSA TNSP",text_var = "sample_number",
      percentVar_obj = results$percent_variance
    )
  )
}


```

# Tibia only pellet
```{r warning=FALSE}
md_df_tibia |>
  dplyr::filter(tissue_celltype_lowercase == "pellet") |>
  dplyr::pull(sampleID)
# colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))


results <- normalize_and_pca(
  count_matrix = m_pca_tibia$matrix_raw_filtered_samples_for_DEG[,md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet") |> dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_tibia$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet",),
  transpose = FALSE
)


for (column_to_plot in colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))) {
#for (column_to_plot in c("Tissue/cell type","Age","health_status","Group", "Plate.ID")) {
  
  if (!(column_to_plot %in% colnames(results$pca_results))) {
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  
  print(
    plot_the_pca(
      pca_df = results$pca_results,
      color_var = column_to_plot,
      shape_var = "Gender",
      pc_x = "PC1", pc_y = "PC2",
      title = "Tibias (Normalized TMM)",
      subtitle = "TSP TNSP",
      text_var = "sample_number",
      percentVar_obj = results$percent_variance
    )
  )
}


```
#Tibia only adipocyte
```{r warning=FALSE}
md_df_tibia |>
  dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
  dplyr::pull(sampleID)
# colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))



results <- normalize_and_pca(
  count_matrix = m_pca_tibia$matrix_raw_filtered_samples_for_DEG[,md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "adipocyte") |> dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_tibia$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "adipocyte"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "adipocyte")))) {
  
  if (!(column_to_plot %in% colnames(results$pca_results))) {
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next 
  }
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias (Normalized TMM)",subtitle = "TSA TNSA",text_var = "sample_number",
                     percentVar_obj = results$percent_variance

      )
    )
}
```



# Lea
# Biological observation
#########################################################################################
# Leas observation, might be the super sclerotic cluster female based?
# Might create a super slerotic samples and compare them to non-sclerotic or mixed? (Wait to confirm with slides)
#########################################################################################



###########################
#      HIP                #
###########################
# Normalized PCA
```{r}
results <- normalize_and_pca(
  count_matrix = m_pca_hip$matrix_raw_filtered_samples_for_DEG,
  gene_info = rownames(m_pca_hip$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_hip,
  transpose = FALSE)

#md_df_tibia$Age <- as.factor(md_df_tibia$Age)
for (column_to_plot in c("Tissue/cell type","Age","health_status","Group", "Plate.ID")) {
  
  if (!(column_to_plot %in% colnames(results$pca_results))) {
    message(paste("Skipping", column_to_plot, "- not found in PCA results")) 
    next
  }
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Hips (Normalized TMM)",subtitle = "HSA HSP HNSA HNSP",text_var = "sample_number",percentVar_obj = results$percent_variance
      )
    )
}
  

```



#Hip only adipocyte
```{r warning=FALSE}
md_df_hip |>
  dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
  dplyr::pull(sampleID)
# colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))



results <- normalize_and_pca(
  count_matrix = m_pca_hip$matrix_raw_filtered_samples_for_DEG[,md_df_hip |>
                                                                 dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                 dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_hip$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "adipocyte"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "adipocyte")))) {
  if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA reseults"))
    next
  }
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(
    plot_the_pca(
      pca_df = results$pca_results,
      color_var = column_to_plot,
      shape_var = "Gender",
      pc_x = "PC1", pc_y = "PC2",
      title = "Hips (Normalized TMM)",subtitle = "HSA HNSA",text_var = "sample_number",
      percentVar_obj = results$percent_variance
      )
    )
}
```
#Hip only pellet
```{r warning=FALSE}
md_df_hip |>
  dplyr::filter(tissue_celltype_lowercase == "pellet") |>
  dplyr::pull(sampleID)
# colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))



results <- normalize_and_pca(
  count_matrix = m_pca_hip$matrix_raw_filtered_samples_for_DEG[,md_df_hip |>
                                                                 dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                                 dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_hip$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "pellet"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "pellet")))) {
  
  if (!(column_to_plot %in% colnames(results$pca_results))) {
    message(paste("Skipping",column_to_plot,"- not found in PCA results"))
    next
  }
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Hips (Normalized TMM)",subtitle = "HSP HNSP",text_var = "sample_number",
      percentVar_obj = results$percent_variance
      )
    )
}
```

# Add up and check differences only between sclerotic and non sclerotic
# Generate metadata
```{r}
md_df_tibia$barcode_tissue <- paste0(md_df_tibia$barcode,"_tibia")
md_df_tibia$Plate.ID_tissue <- paste0(md_df_tibia$Plate.ID,"_tibia")
md_df_hip$barcode_tissue <- paste0(md_df_hip$barcode,"_hip")
md_df_hip$Plate.ID_tissue <- paste0(md_df_hip$Plate.ID,"_hip")

md_df_bone <- rbind(md_df_tibia,md_df_hip)

md_df_bone |>
  dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
  dplyr::pull(sampleID)
# colnames(md_df_tibia |> dplyr::filter(tissue_celltype_lowercase == "pellet"))
```

# Generate matrix for PCA of samples together.
## Unique genes to tibia
## Unique genes to hip
## Common genes to both samples
```{r}
# m_pca_tibia <- run_pca_structuring(matrix_data = matrix_counts_tibia,transpose = FALSE,filter_empty_samples_counts = 30)
# m_pca_hip <- run_pca_structuring(matrix_data = matrix_counts_hip,transpose = FALSE,filter_empty_samples_counts = 30)


path="~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/"
# Save genes unique to TIBIA
# there are already 2.4k genes in tibia  are diffent to hip
length(setdiff(rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG),rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG)))


write.table(x = setdiff(rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG),rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG)),
            file = paste0(path,"unique_genes_of_TIBIA.txt"),sep = "\t", row.names = FALSE, col.names = FALSE)

# Save genes unique to HIP, 1.5k genes in hip are different to tibia
length(setdiff(rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG),rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG)))
write.table(x = setdiff(rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG),rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG)),
            file = paste0(path,"unique_genes_of_HIP.txt"),sep = "\t", row.names = FALSE, col.names = FALSE)


# Find common genes between TIBIA and HIP datasets
common_genes <- intersect(rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG), rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG))

# Save the list of common genes to a file
write.table(x = common_genes, file = paste0(path, "common_genes_to_TIBIA_and_HIP.txt"), sep = "\t", row.names = FALSE, col.names = FALSE)

# Combine the data for the common genes from both datasets
m_samples_bone <- cbind(
  m_pca_tibia$matrix_raw_filtered_samples_for_DEG[common_genes, ],
  m_pca_hip$matrix_raw_filtered_samples_for_DEG[common_genes, ]
)
```


```{r,fig.width=12,fig.height=5}
head(m_samples_bone)

# Calculate column sums, number of counts
col_sums <- colSums(m_samples_bone)

# Create a data frame for plotting
df <- data.frame("Sample" = names(col_sums), "Sum" = col_sums)

# Merge with metadata to get group information
df <- df %>%
  left_join(md_df_bone, by = c("Sample" = "sampleID"))


# Calculate percentiles
percentiles <- quantile(df$Sum.x, probs = c(0.25, 0.5, 0.75, 0.90))
# Mean
mean_sum <- mean(df$Sum.x)


# Create the bar plot
ggplot(df, aes(x = reorder(Column, Sum.x), y = Sum.x, fill= Group)) +
  
  geom_bar(stat = "identity") +
  geom_hline(aes(yintercept = mean_sum, color = "Mean"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = percentiles[1], color = "25th Percentile"), linetype = "dotted", size = 1) +
  geom_hline(aes(yintercept = percentiles[3], color = "75th Percentile"), linetype = "dotted", size = 1) +
  geom_hline(aes(yintercept = percentiles[4], color = "90th Percentile"), linetype = "dotted", size = 1) +
  scale_color_manual(values = c("red", "blue", "green","#903498"),
                     breaks = c("Mean", "25th Percentile", "75th Percentile", "90th Percentile"),
                     name = "Statistics") +  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        axis.text.y = element_text(size = 12),
        panel.background = element_blank(),  # Remove panel background
        panel.grid.major = element_blank(),  # Remove major grid lines
        panel.grid.minor = element_blank(),  # Remove minor grid lines
        ) +  # Rotate x-axis labels for better visibility
  #geom_hline(yintercept = percentiles, linetype = "dashed", color = "red") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title = "Column Sums of Each Sample", x = "Sample", y = "Sum")
```

# STRUCTURING FUCTION 2 to avoid refiltering the samples... that are already filtered.. 
# Here we use the new matrix containing all samples.

```{r}
run_pca_structuring_2 <- function(matrix_data,transpose=FALSE,filter_empty_samples_counts=30,md_df=NULL){
  
  data_matrix_raw <- matrix_data
  #check duplications, they are quite awkward gene namse =()
  #data_matrix_raw <- data_matrix_raw[!duplicated(data_matrix_raw$Gene_name), ]
  #rownames(data_matrix_raw) <- data_matrix_raw$Gene_name
  
  #data_matrix_raw <- data_matrix_raw[,3:ncol(data_matrix_raw)]
  row_sums = rowSums(data_matrix_raw)
  data_matrix_filtered = data_matrix_raw[row_sums >= filter_empty_samples_counts,]
  #data_matrix <- data_matrix_filtered
  # 
  # # Remove constant/zero columns
  # non_constant_columns <- apply(data_matrix_filtered, 2, function(x) sd(x) != 0)
  # data_matrix_filtered <- data_matrix_filtered[, non_constant_columns]

  
  # Run PCA
  # Check transpose
  # Ensure numeric matrix
  data_matrix_filtered <- as.matrix(data_matrix_filtered)
  if (!is.numeric(data_matrix_filtered)) {
    stop("PCA input must be numeric.")
  }
  
  # Run PCA based on transpose parameter
  if (transpose) {
    # Samples as rows, genes as columns
    if (ncol(data_matrix_filtered) < 2 || nrow(data_matrix_filtered) < 2) {
      stop("Not enough data points for PCA after transpose.")
    }
    m <- prcomp(t(data_matrix_filtered), scale. = TRUE, center = TRUE)
    # For transpose=TRUE, rotation contains sample loadings
    m_df <- as.data.frame(m$rotation)
  } else {
    # Genes as rows, samples as columns  
    if (nrow(data_matrix_filtered) < 2 || ncol(data_matrix_filtered) < 2) {
      stop("Not enough data points for PCA.")
    }
    m <- prcomp(data_matrix_filtered, scale. = TRUE, center = TRUE)
    # For transpose=FALSE, x contains sample scores
    m_df <- as.data.frame(m$rotation)
  }
  
  m_df$sample_id <- rownames(m_df)
  
  # Merge with metadata if provide and the data matrix was transposed else do not merge
  #  if (transpose && !is.null(md_df)) {
  if (transpose) {
    m_merged <- m_df
  } else {
    m_merged <- merge(x = m_df, y = md_df, by.x = "sample_id", by.y = "full_name", all.x = TRUE)
  }
  
  # Calculate variance explained
  percent_var <- m$sdev^2 / sum(m$sdev^2)
  
  return(list(
    matrix_raw = data_matrix_filtered,
    matrix_pca = m_merged,
    percentVar_obj = percent_var
  ))
}
```





```{r}
#m_samples_bone <- cbind(m_pca_tibia$matrix_raw,m_pca_hip$matrix_raw[3:ncol(m_pca_hip$matrix_raw)])
# If want to avoid a second function, need to add like a column with "Filtered Sample" Yes, No... and check for that column if exist...
m_pca_samples_bone <- run_pca_structuring_2(matrix_data = m_samples_bone,transpose = FALSE,filter_empty_samples_counts = 30,md_df = md_df_bone)
```


```{r,fig.width=12,fig.height=6}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
# Generate the columns in the md_df_bone

for (column_to_plot in c(colnames(md_df_bone))) {
  if (!(column_to_plot %in% colnames(m_pca_samples_bone$matrix_pca))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = m_pca_samples_bone$matrix_pca,
             percentVar_obj = m_pca_samples_bone$percentVar_obj,
             color_var =  column_to_plot,shape_var = "health_status",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias and Hips",text_var = "tissue_celltype_lowercase"
    )
  )
}
```


```{r,fig.width=12,fig.height=6}
plotly::ggplotly(
  plot_the_pca(pca_df = m_pca_samples_bone$matrix_pca,
             percentVar_obj = m_pca_samples_bone$percentVar_obj,
             color_var =  "tissue_lowercase",shape_var = "health_status",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias and Hips",text_var = "sample_number"))
```


```{r,fig.width=12,fig.height=6}
### Need to be run the run_pca_structuring before the plot the pca otherwise the objects mess up
# Generate the columns in the md_df_bone

plot_the_pca(pca_df = m_pca_samples_bone$matrix_pca,
             percentVar_obj = m_pca_samples_bone$percentVar_obj,
             color_var =  "tissue_lowercase",shape_var = "health_status",
             pc_x = "PC1",pc_y = "PC2",
             title="PCA of RNA-seq Raw Data",subtitle = "Tibias and Hips",text_var = "sample_number")

```

# FILTERING SAMPLES
##################################################################################################
#                                                                                                #
# removed samples that did not pass the QC and filtered for genes                                #
# that have accumulated expression <30  across all samples and use them for future DEG           #
#                                                                                                #
##################################################################################################

```{r}
m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG <- m_pca_samples_bone$matrix_raw[,md_df_bone$sampleID]
```

# All 
```{r}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone,
  transpose = FALSE
)

for (column_to_plot in c(colnames(md_df_bone))) {
  if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TSA TSP TNSA TNSP HSA HSP HNSA HNSP",text_var = "sample_number"
      )
    )
}

```



# Sclerotic all
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "sclerotic") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "sclerotic"),
  transpose = FALSE
)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "sclerotic")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
   }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var =  column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TSA TSP HSA HSP",text_var = "sample_number"
      )
    )
}

# Adipo sclerotic 
# Adipo non sclerotic
```
# Non sclerotic all
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "non.sclerotic") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "non.sclerotic"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "non.sclerotic")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,shape_var =  "Gender",
                     pc_x =  "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TNSA TNSP HNSA HNSP",text_var = "sample_number"
      )
    )
}
```




#Sclerotic only Pellets
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TSP HSP",text_var = "sample_number"))
}
```
# Non sclerotic only pellets
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
   }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TNSP HNSP",text_var = "sample_number"
      )
    )
}
```
# Sclerotic adipocytes only
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TSA HSA",text_var = "sample_number"))
}
```

# Non scleoritc adipocytes only
```{r warning=FALSE}
results <- normalize_and_pca(
  count_matrix = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                                   #dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                                   dplyr::pull(sampleID)],
  gene_info = rownames(m_pca_samples_bone$matrix_raw),  # Ensure this is a data frame or matrix
  metadata = md_df_bone |> dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte"),
  transpose = FALSE)

for (column_to_plot in c(colnames(md_df_bone |> dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte")))) {
  #print(plotly::ggplotly(plot_the_pca(pca_df = y_normalized_corrected_pcas_df,
   if (!(column_to_plot %in% colnames(results$pca_results))){
    message(paste("Skipping", column_to_plot, "- not found in PCA results"))
    next
  }
  print(
    plot_the_pca(
      pca_df = results$pca_results,
                     percentVar_obj = results$percent_variance,
                     color_var = column_to_plot,
                     shape_var = "Gender",
                     pc_x = "PC1", pc_y = "PC2",
                     title = "Tibias and Hips (Normalized TMM)",subtitle = "TNSA HNSA",text_var = "sample_number"
      )
    )
}
```
# volcano function
```{r}
plot_volcano <- function(results_table, 
                         gene_column = "genes", 
                         logFC_column = "logFC", 
                         FDR_column = "FDR", 
                         genes_of_interest = NULL, 
                         output_file = paste0("volcano_plot.",format_plot),
                         #output_file = NULL,
                         format_plot = "svg",
                         up_color = "#d00000", 
                         down_color = "#3f88c5", 
                         ns_color = "#f2e9e4", 
                         up_size = 2, 
                         down_size = 2, 
                         ns_size = 1,
                         up_alpha = 1, 
                         down_alpha = 1, 
                         ns_alpha = 0.5,
                         x_limits = c(-10, 10),
                         y_threshold = -log10(0.05),
                         x_label = "Log2 Fold Change",
                         y_label = "-Log10 Adjusted P-Value") {
  
  # Mutate the gene type
  # results_table <- results_table |>
  #   dplyr::mutate(gene_type = dplyr::case_when(
  #     !!rlang::sym(logFC_column) > 1 & !!rlang::sym(FDR_column) < 0.05 ~ "Upregulated",
  #     !!rlang::sym(logFC_column) < -1 & !!rlang::sym(FDR_column) < 0.05 ~ "Downregulated",
  #     TRUE ~ "Not selected"
  #   )) |>
  #   dplyr::filter(!!rlang::sym(gene_column) != "")
  # To avoid using rlang::sym() which makes the part of the df as a variable use better .data This avoids the rlang::sym()/!! combo, which can be harder to read and debug.


  results_table <- results_table |> 
    dplyr::mutate(gene_type = dplyr::case_when(
      .data[[logFC_column]] > 1 & .data[[FDR_column]] < 0.05 ~ "Upregulated",
      .data[[logFC_column]] < -1 & .data[[FDR_column]] < 0.05 ~ "Downregulated",
      TRUE ~ "Not selected"
    )) |>
    dplyr::filter(.data[[gene_column]] != "")
  
  
  
  # Get the top up and down genes
  ints_up <- results_table |>
    dplyr::filter(!!rlang::sym(FDR_column) < 0.05 & !!rlang::sym(logFC_column) > 1) |>
    dplyr::arrange(!!rlang::sym(FDR_column)) |>
    dplyr::slice(1:10) |>
    dplyr::pull(!!rlang::sym(gene_column))
  
  ints_down <- results_table |>
    dplyr::filter(!!rlang::sym(FDR_column) < 0.05 & !!rlang::sym(logFC_column) < -1) |>
    dplyr::arrange(!!rlang::sym(FDR_column)) |>
    dplyr::slice(1:10) |>
    dplyr::pull(!!rlang::sym(gene_column))
  
  ints <- c(ints_up, ints_down)
  
  ints_genes <- results_table |>
    dplyr::filter(!!rlang::sym(gene_column) %in% ints) |>
    dplyr::distinct(!!rlang::sym(gene_column), .keep_all = TRUE)
  
  if (!is.null(genes_of_interest)) {
    to_add_genes <- results_table |>
      dplyr::filter(!!rlang::sym(gene_column) %in% genes_of_interest) |> 
      dplyr::mutate(gene_type = dplyr::case_when(
        !!rlang::sym(logFC_column) > 1 & !!rlang::sym(FDR_column) < 0.05 ~ "Upregulated",
        !!rlang::sym(logFC_column) < -1 & !!rlang::sym(FDR_column) < 0.05 ~ "Downregulated",
        TRUE ~ "Not Selected"))
    results_table <- rbind(results_table, to_add_genes)
    ints_genes <- rbind(ints_genes, to_add_genes)
  }
  
  # Define the plot
  p <- results_table |>
    ggplot(aes(x = !!rlang::sym(logFC_column),
               y = -log10(!!rlang::sym(FDR_column)))) +
    geom_point(aes(colour = gene_type), 
               alpha = 0.8, 
               shape = 16,
               size = 1) +
    geom_hline(yintercept = y_threshold,
               linetype = "dashed") + 
    geom_vline(xintercept = c(log2(0.5), log2(2)),
               linetype = "dashed") +
    geom_point(data = dplyr::filter(ints_genes, gene_type == "up"),
               shape = 21,
               size = 2,
               fill = "tomato3", 
               colour = "black") + 
    geom_point(data = dplyr::filter(ints_genes, gene_type == "down"),
               shape = 21,
               size = 2,
               fill = "steelblue", 
               colour = "black") +
    geom_label_repel(data = ints_genes, # Add labels last to appear as the top layer  
                     aes(label = !!rlang::sym(gene_column)),
                     force = 2,
                     nudge_y = .2, nudge_x = 0.1,
                     max.overlaps = 30, size = 2) +
    scale_color_manual(values = c("Upregulated" = up_color,
                                  "Downregulated" = down_color,
                                  "Not Selected" = ns_color)) +
    scale_x_continuous(breaks = c(seq(-10, 10, 2)),     
                       limits = x_limits) +
    labs(x = x_label, y = y_label, color = "Genes") +#title = title

    #theme_void() +  # Remove background
    #theme(legend.position = "none")  # Remove legend if not needed
    theme_classic(base_size = 14) +
    theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    legend.position = "right",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )
  
  if (!is.null(genes_of_interest)) {
    p <- p + geom_point(data = to_add_genes,
                        shape = 21,
                        size = 2.4,
                        fill = "#70e000", 
                        colour = "black")
    }
  # Save the plot
  if (!is.null(output_file)) {
    ggsave(plot = p,
           filename = output_file,
           device = format_plot,
           dpi = 300,
           units = "in",
           width = 5, height = 7)
  }
  
  return(p)
}

```

###################
#       DEG       #
###################
```{r}

# Define function to test for differential expression
test_diff_exp <- function(counts, conditions,ensembl_genes,batch=NULL,control_condition,patient=NULL) {
  
  # # Argument validation
  # if (!is.data.frame(counts) || !is.character(conditions) || is.null(ensembl_genes)) {
  #   stop("Invalid input data.")
  # }
  # 
  
  # Ensure 'conditions' is a factor with as the reference level for this experiment, to be compared to
  conditions <- factor(conditions)
  conditions <- relevel(conditions, ref = control_condition)
  # Now defining the reference becomes the right part of the comparison where we are looking at the baseline of non.sclerotic as reference to compare each gene of the         other condition such as sclerotic now.
  
  message(paste0("Setting up DGEList"))
  d = DGEList(counts = counts, group = conditions, genes = ensembl_genes)
  
  
  
  
   # Convert patient or/and batch to a factor
  # Convert patient and batch to factors if they are provided
  if (!is.null(patient)) {
    patient <- factor(make.names(patient))
    d$samples$patient <- patient
  }
  if (!is.null(batch)) {
    batch <- factor(make.names(batch))
    d$samples$batch <- batch
  }
  

  # Model design
  #design <- model.matrix(~0 + conditions)
  # here samples are not independet so shall not use the 0 and because of paired shall include the patient ID. without intercept is difficult to nterpret batch and patient   rather than using each of the conditions as its own group. is more typical to nclude interccept in paired and mixed#
  #    design <- model.matrix(~0 + conditions + batch + patient)

  
  #design <- model.matrix(as.formula(design_formula), data = d$samples)
  #If not using group in DGE list.
  #design <- model.matrix(~patient + conditions)
  # If declare group above in DGElist, use group instead of conditions.

  # Keep the variables also in the d$samples, but do not forget the different ways of calling
  ###########################################################
  # if (!is.null(patient)) {
   # patient <- factor(make.names(patient))
   # d$samples$patient <- patient
  #}
  ###########################################################

  
  
  # Construct the design matrix formula and matrix
  if (!is.null(batch) && !is.null(patient)) {
    design_formula <- "~batch + patient + group"
    design <- model.matrix(as.formula(design_formula),data = d$samples)
  } else if (!is.null(batch)) {
    design_formula <- "~batch + group" 
    design <- model.matrix(as.formula(design_formula),data = d$samples)
  } else if (!is.null(patient)) {
    design_formula <- "~patient + group"
    design <- model.matrix(as.formula(design_formula),data = d$samples) # <- The comparison between groupHSA and the baseline group (HNSA) is within each patient. 
    # This is the one we want. This controls for the fact that each patient has paired samples, reducing confounding due to patient-specific expression.
    #
    #
  } else {
    design_formula <- "~group"
    design <- model.matrix(as.formula(design_formula),data = d$samples)
  }
  
  # Output the design matrix formula
  message(paste0("Using design matrix formula: ", design_formula))
  message("Using design matrix:")
  print(head(design))
  
  
  
  #perform TMM normalization
  # Filter out lowly expressed genes (less than 30 counts across all samples)
  #This creates a logical vector where each entry indicates whether the corresponding gene has a CPM of at least 1 in at least 2 samples.
  keep <- rowSums(cpm(d) >= 1) >= 2# & rowSums(d$counts) >= 30
  d <- d[keep, , keep.lib.sizes = FALSE]
  
  message("Normalizing using TMM.")
  d <- calcNormFactors(d,method="TMM")
  #An MDS plot shows the similarities between samples based on their expression profiles.
  mds_plot <- plotMDS(d,col=as.numeric(as.factor(conditions)))
  mds_plot <-legend("topright", legend = levels(as.factor(conditions)), col = 1:length(levels(as.factor(conditions))), pch = 16)
  message(paste0("MDS Plot created"))
  
  
  # Save the normalized matrix
  normalized_matrix <- cpm(d, normalized.lib.sizes = TRUE)
  logcpm <- cpm(d, log = TRUE, prior.count = 1, normalized.lib.sizes = TRUE)

  rownames(normalized_matrix) <- d$genes$genes
  
  
 
  
  message(paste0("Estimating dispersion"))
  # Fit the NB GLMs with QL methods
  d <- estimateDisp(d, design)
  #2.
  # Fit the model and perform the differential expression analysis
  library(statmod)
  message(paste0("Fitting the QLNB function."))

  fit <- glmQLFit(d, design,robust = TRUE)
  # it is kind of a shrinkage, leaving very extreme values out of the model, this fits the model to the HSA vs HNSA taking into account patient variability.
  message(paste0("Print dispersion plot"))
  ql_disp_plot <- plotQLDisp(fit)
  
  # Define contrasts, not in ~group
  # Get the comparison name
  non_reference_condition <- gsub(pattern = "group",replacement = "",x = colnames(design)[dim(design)[2]])
  comparison_name <- paste0(non_reference_condition,"-vs-",control_condition)
  message("Performing differential expression analysis.")
  message(paste0("Running contrast on: ",comparison_name))
  

  
  # Perform differential expression analysis
  res <- glmQLFTest(fit) #without ~0+conditions, it performs the last column as contrast, or specify column by coef=32..
  
  # Create a column with the rowSums of the samples in the comparison.
  value1 <- strsplit(x = comparison_name, split = "-vs-")[[1]][1]
  value2 <- strsplit(x = comparison_name, split = "-vs-")[[1]][2]
  
  subset_rows_v1 <- d$samples[d$samples$group == value1, , drop = FALSE]
  subset_rows_v2 <- d$samples[d$samples$group == value2, , drop = FALSE]
    
  sample_names_v1 <- rownames(subset_rows_v1)
  sample_names_v2 <- rownames(subset_rows_v2)
    
  colSum_sample_v1 <- as.matrix(rowSums(d$counts[,sample_names_v1]))
  colSum_sample_v2 <- as.matrix(rowSums(d$counts[,sample_names_v2]))
    
  colnames(colSum_sample_v1) <- paste0("colSums_",subset_rows_v1$group[1])
  colnames(colSum_sample_v2) <- paste0("colSums_",subset_rows_v2$group[1])
  
  colsums_samples <- as.data.frame(d$counts[,c(sample_names_v1,sample_names_v2)])
  colsums_samples$genes <- d$genes$genes
    
  colsums_samples$C1 <- colSum_sample_v1
  colsums_samples$C2 <- colSum_sample_v2
    
  names_to_add_after_colsums <- colnames(colsums_samples)
    
  names_to_add_after_colsums[length(names_to_add_after_colsums) -1] <- paste0("colSums_",subset_rows_v1$group[1])
  names_to_add_after_colsums[length(names_to_add_after_colsums)] <- paste0("colSums_",subset_rows_v2$group[1])
    
  colnames(colsums_samples) <- names_to_add_after_colsums
  #rownames(colsums_samples) <- d$genes$genes
  # Save
  Sys.sleep(1)
  
  # List of top genes
  top_genes <- topTags(res, n = Inf)
  top_gene_names <- top_genes$table$genes[1:10]
  # Prepare the data frame for all top genes
  samples_boxplot <- data.frame(
    samples = rep(colnames(normalized_matrix[top_gene_names,]), each=1),
    values = as.vector(t(normalized_matrix[top_gene_names,])),
    condition = rep(d$samples$group, length(top_gene_names)),
    gene = rep(top_gene_names, each = ncol(normalized_matrix))
  )

  # # Assigning colors to conditions
  # color_mapping <- c("non.sclerotic" = "red", "sclerotic" = "blue")

  # Generate the plot with subplots for each gene
  boxplot_gg <- ggplot(samples_boxplot, aes(x = condition, y = values)) +
    geom_boxplot(aes(group = condition), outlier.shape = NA) + # Remove black outlier points
    geom_jitter(width = 0.2, size = 1.5, alpha = 0.6, aes(color = condition)) + # Map color inside aes()
    #scale_color_manual(values = color_mapping) + # Map colors to conditions
    theme_minimal() +
    labs(subtitle = "Top Genes Normalized Values", x = "Condition", y = "Gene Value",) +
    facet_wrap(~ gene, scales = "free_y") # Create subplots for each gene
  
  
   # Store results and plots in a list
  results_list <- list(
    name = comparison_name,
    results = topTags(res, n = Inf),
    colsums_samples=colsums_samples,
    normalized_matrix=normalized_matrix,
    logcpm = logcpm,
    fit = fit,
    d=d,
    mds_plot = mds_plot,
    ql_disp_plot = ql_disp_plot,
    boxplot_gg = boxplot_gg
  )
  
  message("Differential expression analysis complete.")
  return(results_list)

}

```


# Differential gene expression.

## Separate the data in smaller groups.

```{r}
#tibia#hip#adipo#pellet#sclerotic#non_sclerotic
# Done
# tibias-> sclerotic vs nsclerotic
# Adipocytes Non-sclerotic vs Sclerotic of Tibia
# Pellet Non-sclerotic vs Sclerotic of Tibia

# hip-> sclerotic vs nsclerotic
# Adipocytes Non-sclerotic vs Sclerotic of Hip
# Pellet Non-sclerotic vs Sclerotic of Hip
```

# Save results DEG
```{r}
save_results_deg <- function(result_list, base_path) {
  # Filter results with FDR < 0.05
  filtered_results <- result_list$results$table |> dplyr::filter(FDR < 0.05)
  print(filtered_results)
  
  # Define file paths
  filtered_results_path <- paste0(base_path, "filtered_fdr_0.05_", result_list$name, ".txt")
  results_path <- paste0(base_path, result_list$name, ".txt")
  counts_path <- paste0(base_path, "counts_", result_list$name, ".csv")
  norm_counts_path <- paste0(base_path, "norm_counts_", result_list$name, ".csv")
  boxplot_topTags_path <- paste0(base_path, "boxplot_toptags_genes_", result_list$name, ".svg")
  logcpm_counts_path <- paste0(base_path, "logcpm_counts_", result_list$name, ".csv")
  
  # Write the tables
  write.table(filtered_results, filtered_results_path, sep = "\t", row.names = FALSE, col.names = TRUE)
  write.table(result_list$results$table, results_path, sep = "\t", row.names = FALSE, col.names = TRUE)
  write.table(result_list$colsums_samples, counts_path, sep = ",", row.names = FALSE, col.names = TRUE)
  write.table(result_list$normalized_matrix, norm_counts_path, sep = ",", row.names = FALSE, col.names = TRUE)
  write.table(result_list$logcpm, logcpm_counts_path, sep = ",", row.names = FALSE, col.names = TRUE)
  
  # Save the ggplot as SVG
  svg(filename = boxplot_topTags_path, width = 12, height = 9, pointsize = 12)
  print(result_list$boxplot_gg)  # Print the ggplot object to the device
  dev.off()  # Close the device
  
  message("Results and plots have been successfully saved.")
}

# # Example usage
# base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/pellets_patient/pellet_tibia_and_hip_"
# save_results_deg(result_list = pellets_hip_and_tibia_sclerotic_vs_non_sclerotic, base_path)




```

#########################
RUN DEA,by models using batch,patient, or nothing but the condition.
~0+patient+conditions: each group is considered independient and we measure the gene exprssion absolute difference from sample to sample or contrasts.

~patient+conditions: we use this because the data is paired, if more complicated designs to change contrasts can be done using no intercept. we meassure each gene expression using one condition as reference and how much are the difference between reference and control, assuming as above too, that there is no difference as Ho(null) and that there is difference as Ha(alternative)

by not using a intercept it is easier to make contrasts
with intercept, still can be compared many options, but it is more difficult to interpret if the diffrence is only biological and how to clearly separate it the study has more variables, despite using no intercept you can measure directly "absolute differences"

In order to set a referenc, use relevel, this is going to be set as the condition to be the intercept, to which th other condition will be compared. (both DESeq2 and edgeR)
if using for example non.sclerotic and sclerotic. and we use ~condition, we use non.sclerotic as ref, therefore the model will become, iintercept with non.sclerotic and the last column the combination of model.matrix with non.sclerotics as 0 and sclerotics as 1,defining already the contrast to be done. Where the last column is already the difference to the mean of the baseline of the non.sclerotic to sclrotic.


If we use ~0+condition each becomes a column to be tested the means of each gene.

If we use patient or batch, you need to put before the condition of nterest in the model. They will help to explain f there are differences between samples that could hide the effects of the condition.

for te logFC, the reference sample will be used as baseline to compare the experimental to the reference. such as: experiment vs reference, here the positive logFC would represent higher value of expression in experiment, if wanna change the order use relevel.
Check the boxplot_gg of the topTags that includes for this reason the baseline to the left of the plot and experiment to the right. showing graphically the normalized counts values of the topTags genes.

use edgeR manual for more and linear algebra and beatiful model fittings lessons n statistics and maths


What Happens Mathematically
Mathematically, if we denote:

𝑌𝑖𝑗

Y as the gene expression count for gene𝑖in sample 𝑗.
𝜇𝑖𝑗as the mean expression level for gene 𝑖 in sample j

𝑖ϕ i as the dispersion parameter for gene 𝑖i.

The model in edgeR can be written as:
𝑌𝑖𝑗∼Negative Binomial(𝜇𝑖𝑗,𝜙𝑖)

 where:log⁡(𝜇𝑖𝑗)=𝛽0+𝛽𝑝𝑎𝑡𝑖𝑒𝑛𝑡𝑗+𝛽𝑐𝑜𝑛𝑑𝑖𝑡𝑖𝑜𝑛𝑗log(μ ij​ )=β 0​ +β patient j +β condition j
 β 0: Intercept term (baseline log-expression level for the reference patient and condition).
 
 𝛽𝑝𝑎𝑡𝑖𝑒𝑛𝑡𝑗 : Coefficients representing the effect of patient 𝑗

𝛽𝑐𝑜𝑛𝑑𝑖𝑡𝑖𝑜𝑛𝑗: Coefficients representing the effect of the condition (sclerotic vs. non-sclerotic).

The patient coefficients (𝛽𝑝𝑎𝑡𝑖𝑒𝑛𝑡) adjust for each patient’s baseline expression level, which helps to isolate the true effect of the condition (𝛽𝑐𝑜𝑛𝑑𝑖𝑡𝑖𝑜𝑛) on gene expression. This adjustment is crucial when there is variability across patients, which could otherwise confound the condition effect.


Practical Implications
Removing Confounding Effects: By accounting for patient-specific effects, the model reduces potential confounding. For example, if some patients inherently have higher gene expression levels due to other biological factors, this variability won’t distort the estimation of the condition effect.

Improved Accuracy: Including patient in the model improves the accuracy of detecting differentially expressed genes by reducing noise from between-patient variability.

More Realistic Estimates: The inclusion of patient as a random effect or as a fixed effect (depending on how it's treated in your specific analysis) provides more realistic estimates of gene expression changes due to condition, not due to differences in baseline expression across patients.

# Interaction, to do later, so we can see how the HSA vs HNSA can vary also among patient, as without interaction like now, we consider "constant or consistent across the group" but the truth is that each sample can have more or less sclerotic.. or non sclerotic...
###  The effect of the group (sclerotic vs non-sclerotic) can differ by patient. 
###### We would allow the effect of sclerotic vs non-sclerotic to vary patient-by-patient. #######
###  For example, some patients might have a large difference between HSA and HNSA samples, others might have a small or even opposite difference.
### Using -> ~patient + group + patient:group (~patient * group)
# HIP

## HIP Adipocytes Sclerotic vs non sclerotic
```{r}
# Measure the time taken to run the function and store the result
time_taken <- system.time({
  hip_adipocytes_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts = m_pca_hip$matrix_raw_filtered_samples_for_DEG[,md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "adipocyte") |> dplyr::pull(sampleID)],
                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>

    conditions = md_df_hip |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(Group) |> factor(),
      #batch = md_df_hip |>dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      #dplyr::pull(sample_number)#dplyr::filter(health_status ==   "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>,
    patient = md_df_hip |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(sample_number) |> factor(),
    ensembl_genes = rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG),
    control_condition = "HNSA")
  # Print the time taken to run the function
})

print(time_taken)
```
# Visualize fitted values and residuals from edgeR after modelling via PCA.
```{r}
# Fitted values and residuals, raw filtered counts are inside the d$counts
fit_edgeR <- hip_adipocytes_sclerotic_vs_non_sclerotic$fit$fitted.values
keep <- rowSums(cpm(d) >= 1) >= 2
d <- d[keep, , keep.lib.sizes = FALSE]
residuals_edgeR <- d$counts - fit_edgeR
#residuals_edgeR <- residuals(fit)

#####################################################################################
# Convert to log2CPM as the distribution in edgeR and deseq2 is still in "counts"   #
#####################################################################################

# Convert fitted values to log2CPM
log2_fitted_edgeR <- cpm(fit_edgeR, log = TRUE, prior.count = 1)

# Residuals: convert counts & fitted to log2CPM first, then subtract
log2_counts_edgeR <- cpm(d$counts, log = TRUE, prior.count = 1)
log2_residuals_edgeR <- log2_counts_edgeR - log2_fitted_edgeR

# PCA on fitted values, what does the model predicts expects.
pca_edgeR_fit <- prcomp(t(log2_fitted_edgeR), scale. = TRUE, center=TRUE) #what does the model explain (here shall come separated by HNSA vs HSA and not patient as it is removed..)
pca_edgeR_residuals <- prcomp(t(log2_residuals_edgeR), scale. = TRUE, center = TRUE) #what does the model not explain, here patient shall be mixed, as theoretically we modeled it.

edgeR_var_f <- summary(pca_edgeR_fit)$importance[2, 1:2] * 100
edgeR_var_r <- summary(pca_edgeR_residuals)$importance[2, 1:2] * 100

 
# Create formatted axis labels
edgeR_labels_f <- paste0("PC", 1:2, " (", round(edgeR_var_f, 1), "%)")
edgeR_labels_r <- paste0("PC", 1:2, " (", round(edgeR_var_r, 1), "%)")

label_df <- data.frame(
  Method = c("edgeR_fitted_values", "edgeR_residuals"),
  x_label = c(edgeR_labels_f[1], edgeR_labels_r[1]),
  y_label = c(edgeR_labels_f[2], edgeR_labels_r[2])
)


# Build tidy data frames
edgeR_f_df <- data.frame(
  PC1 = pca_edgeR_fit$x[,1],
  PC2 = pca_edgeR_fit$x[,2],
  Method = "edgeR_fitted_values",
  Group = factor(d$samples$group),
  Patient = factor(d$samples$patient)
)

edgeR_r_df <- data.frame(
  PC1 = pca_edgeR_residuals$x[,1],
  PC2 = pca_edgeR_residuals$x[,2],
  Method = "edgeR_residuals",
  Group = factor(d$samples$group),
  Patient =  factor(d$samples$patient)
)

# Combine for joint plotting
combined_df <- rbind(edgeR_f_df, edgeR_r_df)
combined_df <- merge(combined_df, label_df, by = "Method")


library(ggplot2)

for (colorin in c("Group", "Patient")){
  p <- ggplot(combined_df, aes(x = PC1, y = PC2, color = .data[[colorin]])) +
    geom_point(size = 2, alpha = 0.7) +
    facet_wrap(~ Method) +
    labs(title = "PCA Comparison: edgeR logCPM(intersample-variability modelled fitted values)\n vs edgeR logCPM (intersample-variability modelled residuals)",
        x = "Principal Component 1",
        y = "Principal Component 2") +
    theme(plot.title = element_text(hjust=0.5,size = 5,face = "bold")) +
    geom_text(
      data = unique(combined_df[, c("Method", "x_label", "y_label")]),
      aes(x = Inf, y = Inf, label = paste(x_label, "\n", y_label)),
      hjust = 1.1, vjust = 1.4,
      inherit.aes = FALSE,
      size = 3
    ) +

    #scale_color_manual(values=c("d1" = "#c1121f", "d0" = "#219ebc")) +
    theme(
      plot.title = element_text(hjust = 0.5),
      strip.text = element_text(face = "bold"))
   # Conditional axis labels based on method
  # p <- p + scale_x_continuous(name = ifelse(unique(combined_df$Method) == "edgeR", edgeR_labels[1], limma_labels[1])) +
  #          scale_y_continuous(name = ifelse(unique(combined_df$Method) == "edgeR", edgeR_labels[2], limma_labels[2]))
  print(p)
}
#
#
### --- Interpretation Notes ---
cat("
PCA Diagnostics Summary:
-------------------------
- PCA of FITTED values shows the variation explained by the model (e.g., treatment effect, day).
- PCA of RESIDUALS shows what's left (hidden batch effects or noise).
- If residual PCA shows clear Day/Batch separation, the model may be missing covariates.
- For a good fit, residuals should show no obvious clustering by known factors.
")
```



```{r}
hip_adipocytes_sclerotic_vs_non_sclerotic$name
print(hip_adipocytes_sclerotic_vs_non_sclerotic$boxplot_gg)
hip_adipocytes_sclerotic_vs_non_sclerotic$results$table
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/hip_patient/"
dir.create(path = base_path)
save_results_deg(hip_adipocytes_sclerotic_vs_non_sclerotic, base_path)
```
```{r}
volcano_hip_adipocytes_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = hip_adipocytes_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",hip_adipocytes_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
                                                                  genes_of_interest = NULL)
```



## HIP Pellet Sclerotic vs non sclerotic
```{r}
time_taken <- system.time({
  hip_pellet_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts =
      m_pca_hip$matrix_raw_filtered_samples_for_DEG[,md_df_hip |>
                                                      dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                      #dplyr::filter(health_status == "non.sclerotic" &tissue_celltype_lowercase == "adipocyte") |>
                                                      dplyr::pull(sampleID)],
    conditions = md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "pellet") |> dplyr::pull(Group),
     #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
    #batch = md_df_hip|>dplyr::filter(tissue_celltype_lowercase == "pellet") |>dplyr::pull(sample_number),
                                                         #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
    ensembl_genes = rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG),
    patient = md_df_hip |> dplyr::filter(tissue_celltype_lowercase == "pellet") |> dplyr::pull(sample_number),
    control_condition = "HNSP")
  # Print the time taken to run the function
  })

print(time_taken)
```
```{r}
hip_pellet_sclerotic_vs_non_sclerotic$name
print(hip_pellet_sclerotic_vs_non_sclerotic$boxplot_gg)
hip_pellet_sclerotic_vs_non_sclerotic$results$table
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/hip_patient/"
dir.create(path = base_path)
save_results_deg(hip_pellet_sclerotic_vs_non_sclerotic, base_path)

```

```{r}
volcano_hip_pellet_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = hip_pellet_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",hip_pellet_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```
## Check!!
The SRPX2 protein contains a TSR-1 domain, which is associated with the extracellular matrix and involved in cell-cell communication. 

# Hip sclerotic vs non sclerotic

```{r}
time_taken <- system.time({
  hip_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts = 
      m_pca_hip$matrix_raw_filtered_samples_for_DEG[,md_df_hip |>
                                                      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                      dplyr::pull(sampleID)],
    conditions = md_df_hip |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(health_status),
    batch = md_df_hip |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(sample_number),
    ensembl_genes = rownames(m_pca_hip$matrix_raw_filtered_samples_for_DEG),
    control_condition = "non.sclerotic")
  
  # Print the time taken to run the function
  })

print(time_taken)
```

```{r}
hip_sclerotic_vs_non_sclerotic$name
print(hip_sclerotic_vs_non_sclerotic$boxplot_gg)
hip_sclerotic_vs_non_sclerotic$results$table
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/hip_patient/"
dir.create(path = base_path)
save_results_deg(hip_sclerotic_vs_non_sclerotic, base_path)
```

```{r}
volcano_hip_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = hip_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="png",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",hip_sclerotic_vs_non_sclerotic$name,".png"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))

#If possible remove ENSEMBLID from volcanoes

```


```{r}
# I have not focused on the DEG, yet.
```
# TIBIA
## Tibia Adipocytes Sclerotic vs non sclerotic
```{r}
time_taken <- system.time({
  tibia_adipocytes_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts =
      m_pca_tibia$matrix_raw_filtered_samples_for_DEG[,md_df_tibia |>
                                                        dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                        #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                        dplyr::pull(sampleID)],
    conditions = md_df_tibia |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(Group),
    batch = md_df_tibia |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(sample_number),
    #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>,
    ensembl_genes = rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG),
    control_condition = "TNSA")}
  )


print(time_taken)
```
```{r}
tibia_adipocytes_sclerotic_vs_non_sclerotic$name
tibia_adipocytes_sclerotic_vs_non_sclerotic$results$table
print(tibia_adipocytes_sclerotic_vs_non_sclerotic$boxplot_gg)
```

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/tibia_patient/"
dir.create(path = base_path)
save_results_deg(tibia_adipocytes_sclerotic_vs_non_sclerotic, base_path)
```

```{r}
volcano_tibia_adipocytes_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = tibia_adipocytes_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",tibia_adipocytes_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```


## TIBIA Pellet Sclerotic vs non sclerotic
```{r}
tibia_pellet_sclerotic_vs_non_sclerotic <- test_diff_exp(
  counts =
    m_pca_tibia$matrix_raw_filtered_samples_for_DEG[,md_df_tibia |>
                                                      dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                      dplyr::pull(sampleID)],
  conditions = md_df_tibia |>
    dplyr::filter(tissue_celltype_lowercase == "pellet") |>
    #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
    dplyr::pull(Group),
  batch = md_df_tibia |>
    dplyr::filter(tissue_celltype_lowercase == "pellet") |>
    #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
    dplyr::pull(sample_number),
  ensembl_genes = rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG),
  control_condition = "TNSP")
```

```{r}
tibia_pellet_sclerotic_vs_non_sclerotic$name
tibia_pellet_sclerotic_vs_non_sclerotic$results$table
print(tibia_pellet_sclerotic_vs_non_sclerotic$boxplot_gg)
```
## NLRP3 inflammasomes! Tibias NSP vs SP

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/tibia_patient/"
dir.create(path = base_path)
save_results_deg(tibia_pellet_sclerotic_vs_non_sclerotic, base_path)
```


```{r}
volcano_tibia_pellet_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = tibia_pellet_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",tibia_pellet_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```
# Tibia sclerotic vs non sclerotic

```{r}

time_taken <- system.time({
  tibia_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts =
      m_pca_tibia$matrix_raw_filtered_samples_for_DEG[,md_df_tibia |>
                                                        #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                        #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                        dplyr::pull(sampleID)],
    conditions = md_df_tibia |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(health_status),
    patient= md_df_tibia |> dplyr::pull(sample_number),
    #batch = md_df_tibia |>dplyr::filter(tissue_celltype_lowercase == "pellet") |>
    #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>,
    ensembl_genes = rownames(m_pca_tibia$matrix_raw_filtered_samples_for_DEG),
    control_condition = "non.sclerotic")
})
print(time_taken)
```
```{r}
tibia_sclerotic_vs_non_sclerotic$name
tibia_sclerotic_vs_non_sclerotic$results$table
print(tibia_sclerotic_vs_non_sclerotic$boxplot_gg)
```

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/tibia_patient/"
dir.create(path = base_path)
save_results_deg(tibia_sclerotic_vs_non_sclerotic, base_path)
```


```{r}
volcano_tibia_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = tibia_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",tibia_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```

# Bone
## Hip and tibias

```{r}

```

```{r}
time_taken <- system.time({
  bone_tibia_vs_hip <- test_diff_exp(
    counts =
      m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                               #dplyr::filter(tissue_celltype_lowercase == "pellet")|>
                                                               #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                               dplyr::pull(sampleID)],
    conditions = md_df_bone |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(tissue_lowercase),
    batch = md_df_bone |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |> 
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") 
      dplyr::pull(tissue_celltype_lowercase),
    #patient = md_df_bone |>dplyr::pull(tissue_lowercase),
    ensembl_genes = rownames(m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG),
    control_condition = "hip")
  
})
print(time_taken)

```

```{r}
bone_tibia_vs_hip$name
bone_tibia_vs_hip$results$table
bone_tibia_vs_hip$boxplot_gg
```
# B2M --> related to MHC complex I (internal protein presentations or cross-presentation (immunology))

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/bone/"
dir.create(path = base_path)
save_results_deg(bone_tibia_vs_hip, base_path)
```
# Non sclerotic bone
```{r}
time_taken <- system.time({
  bone_non_sclerotic_tibia_vs_hip <- test_diff_exp(
    counts =
      m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                               #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                               #dplyr::filter(health_status == "non.sclerotic" &tissue_celltype_lowercase == "adipocyte") |>
                                                               dplyr::filter(health_status == "non.sclerotic") |> 
                                                               dplyr::pull(sampleID)],
    conditions = md_df_bone |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::filter(health_status == "non.sclerotic") |> 
      dplyr::pull(tissue_lowercase),
    batch = md_df_bone |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::filter(health_status == "non.sclerotic") |> 
      dplyr::pull(tissue_celltype_lowercase),
    ensembl_genes = rownames(m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG),
    control_condition = "hip")
  })

print(time_taken)
```
```{r}
bone_non_sclerotic_tibia_vs_hip$name
bone_non_sclerotic_tibia_vs_hip$results$table
print(bone_non_sclerotic_tibia_vs_hip$boxplot_gg)
```
# ribosomes and mhc complex-i again.

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/bone/non_sclerotic_"
dir.create(base_path)
save_results_deg(bone_non_sclerotic_tibia_vs_hip, base_path)
```
# Sclerotic bone 
```{r}
time_taken <- system.time({
  bone_sclerotic_tibia_vs_hip <- test_diff_exp(
    counts = 
      m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                               #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                               #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                               dplyr::filter(health_status == "sclerotic") |> 
                                                               dplyr::pull(sampleID)],
    conditions = md_df_bone |> 
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>         
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::filter(health_status == "sclerotic") |> 
      dplyr::pull(tissue_lowercase),
    batch = md_df_bone |>
      #dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::filter(health_status == "sclerotic") |>
      dplyr::pull(tissue_celltype_lowercase),
    ensembl_genes = rownames(m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG),
    control_condition = "hip")
  })

print(time_taken)
```
```{r}
bone_sclerotic_tibia_vs_hip$name
bone_sclerotic_tibia_vs_hip$results$table
print(bone_sclerotic_tibia_vs_hip$boxplot_gg)
```

```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/bone/sclerotic_"
dir.create(path = base_path)
save_results_deg(bone_sclerotic_tibia_vs_hip, base_path)
```

```{r}

```

<!-- # bone adipocytes -->

<!-- ```{r} -->
<!-- bone_adipocytes_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             dplyr::filter(tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             dplyr::filter(tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/adipocytes_" -->
<!-- save_results_deg(bone_adipocytes_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->

<!-- # bone pellet -->
<!-- ```{r} -->
<!-- bone_pellet_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             #dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/pellet_" -->
<!-- save_results_deg(bone_pellet_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->




<!-- ```{r} -->
<!-- # Bone Tibia vs Hip  -->
<!-- # Bone Adipocyte -> tibia vs Hip -->
<!-- # Bone Pellet -> tibia vs Hip -->
<!-- # Bone Non Sclerotic -> tibia vs hip -->
<!-- # Bone Sclerotic -> tibia vs hip -->


<!-- #Done -->
<!-- ``` -->


<!-- # tibia vs  hip sclerotic pellet -->

<!-- ```{r} -->
<!-- bone_sclerotic_pellet_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/sclerotic_pellet_" -->
<!-- save_results_deg(bone_sclerotic_pellet_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->

<!-- # tibia vs  hip non.sclerotic pellet -->
<!-- ```{r} -->
<!-- bone_non_sclerotic_pellet_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/non_sclerotic_pellet_" -->
<!-- save_results_deg(bone_non_sclerotic_pellet_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->


<!-- #tibia vs  hip non.sclerotic adipocyte -->
<!-- ```{r} -->
<!-- bone_non_sclerotic_adipocyte_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "non.sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/non_sclerotic_adipocyte_" -->
<!-- save_results_deg(bone_non_sclerotic_adipocyte_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->
<!-- # tibia vs  hip sclerotic adipocyte -->
<!-- ```{r} -->
<!-- bone_sclerotic_adipocyte_hip_vs_tibia <- test_diff_exp(counts = m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |> -->
<!--                                                                                                      #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                                                                      dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                                                                      dplyr::pull(sampleID)], -->
<!--                                                           conditions = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(tissue_lowercase), -->
<!--                                                           batch = md_df_bone |> -->
<!--                                                             #dplyr::filter(tissue_celltype_lowercase == "pellet") |> -->
<!--                                                             dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |> -->
<!--                                                             dplyr::pull(sample_number), -->
<!--                                                           ensembl_genes = m_pca_samples_bone$matrix_raw[,2]) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples/DGE_Results_tables/bone/sclerotic_adipocyte_" -->
<!-- save_results_deg(bone_sclerotic_adipocyte_hip_vs_tibia[[1]], base_path) -->
<!-- ``` -->




# All adipocytes
# Adipocytes bone
## Non-sclerotic vs Sclerotic 

```{r}
time_taken <- system.time({
  adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts = 
      m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                               dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
                                                               #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
                                                               dplyr::pull(sampleID)],
    conditions = md_df_bone |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(health_status),
    patient = md_df_bone |>
      dplyr::filter(tissue_celltype_lowercase == "adipocyte") |>
      #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(sample_number),
    ensembl_genes = rownames(m_pca_samples_bone$matrix_raw),
    control_condition = "non.sclerotic")
  })
print(time_taken)
```


```{r}
adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$name
adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table
print(adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$boxplot_gg)
head(adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$fit$design)
```


```{r}
base_path <- "/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/adipocytes_patient/adipocyte_tibia_and_hip"
dir.create(path = base_path,recursive = TRUE)
save_results_deg(adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic, base_path)
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/adipocytes_patient/"
volcano_adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",adipocyte_hip_and_tibia_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```


# All pellets
# pellets bone
## Non-sclerotic vs Sclerotic
```{r}
time_taken <- system.time({
  pellets_hip_and_tibia_sclerotic_vs_non_sclerotic <- test_diff_exp(
    counts = 
      m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG[,md_df_bone |>
                                                               dplyr::filter(tissue_celltype_lowercase == "pellet") |>
                                                               #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase=="adipocyte") |>
                                                               dplyr::pull(sampleID)],
    conditions = md_df_bone |> dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(health_status),
    patient = md_df_bone |>
      dplyr::filter(tissue_celltype_lowercase == "pellet") |>
      #dplyr::filter(health_status == "sclerotic" & tissue_celltype_lowercase == "adipocyte") |>
      dplyr::pull(sample_number),
    ensembl_genes = rownames(m_pca_samples_bone$matrix_raw_filtered_samples_for_DEG),
    control_condition = "non.sclerotic")
  
})
print(time_taken)
```


```{r}
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$name
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$bo
head(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$fit$desing)
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets_patient/pellet_tibia_and_hip_"
dir.create(path = base_path,recursive = TRUE)
save_results_deg(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic, base_path)
```


```{r}
base_path <- "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets_patient/"
volcano_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic <- plot_volcano(results_table = pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table,
                                                                  format_plot="svg",
                                                                  output_file = paste0(base_path,"Volcano/volcano_",pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$name,".svg"),
                                                                  gene_column = "genes",
                                                                  genes_of_interest = NULL)
                                                                  #genes_of_interest = c("IL11","RCN2", "IL11", "CNTNAP2", "STMN2"))
```




# Adipocytes non sclerotic tibia vs hip
```{r}
#todo
```

# Adipocytes sclerotic tibia vs hip
```{r}
#todo
```




# Perform enrichR
```{r}
#install.packages("enrichR")
library(enrichR)
```


```{r}
setEnrichrSite("Enrichr") # Human genes
```
```{r}

websiteLive <- getOption("enrichR.live")
if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr") # Human genes   
}
if (websiteLive) dbs <- listEnrichrDbs()
#dbs <- listEnrichrDbs()
dbs
```

```{r}
#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> dplyr::filter(FDR < 0.05)
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05)


message(paste0("Working on sample: ",pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$name))

dbs <- c('GO_Cellular_Component_2017','GO_Molecular_Function_2017','GO_Biological_Process_2017','CellMarker_2024')
enriched <- enrichr(genes = c(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05) |> 
                      #dplyr::filter(!grepl(x = genes,pattern = "^Gm\\d+")) |>
                      #dplyr::filter(!grepl(x = genes,pattern = "*Rik$")) |> 
                      dplyr::filter(!is.na(genes)) |> 
                      dplyr::filter(genes != "") |>
                      dplyr::filter(!grepl(x = genes, pattern = "ENSG")) |>
                      dplyr::pull(genes)), databases = dbs)

enriched
```


```{r}
enriched[["CellMarker_2024"]]
# plot the enrichment 3 from dbs GOBP
```


```{r}
enriched
enriched$CellMarker_2024
```


```{r}
plotEnrich(enriched[[4]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")
```

# check universe.
```{r}
library(ggplot2)
library(ggraph)

lapply(names(enriched), function(y) {
  x = pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$name
  tryCatch({
    message("Save the enrichment for comparison: ",
            x,
            " and enrichment: ", y)
    # Save the enrichment to a table
    write.table(x = enriched[[y]],
                file = paste0("~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Enrichr/", y,
                              "_for_comparison_",
                              x,
                              ".txt"),
                sep = "\t",
                row.names = FALSE,
                col.names = TRUE)
    message("Save the plot for comparison: ", x, " and enrichment: ", y)
    # Save the plot to a PDF
    ggsave(plot = plotEnrich(enriched[[y]],
                             showTerms = 30, numChar = 40, y = "Count",
                             orderBy = "Adjusted.P.value",
                             title = paste0("Enrichment analysis by Enrichr", y, " in: ", x)),
           filename = paste0("~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Enrichr/",
                             y,
                             "_for_comparison_",
                             x,
                             "_barplot.pdf"),
           device = "pdf",
           width = 12,
           height = 9)
    },
    error = function(e) {
      message("There was an error with enrichment ", y, " in comparison ", x, ": ", e)
      })
})

```

# Add all comparisons in a list
```{r}
ls(all.names = TRUE)
# Get all object names that match a pattern
comparison_names <- ls(pattern = "vs")
comparison_names
```
```{r}
# Retrieve the comparisons and put them into a list
comparisons_list <- mget(comparison_names[!grepl(pattern ="^volcano_*",x =  comparison_names)])
comparisons_list
```

# Volcanos 
```{r}

# old function

library(ggplot2)
library(ggrepel)

volcano_plot_function <- function(df_cond, lg2fc_p, log2fc_n, p_adj, title_, colordown, colorup, down_e, up_e, top_rows_to_select_genes) {
  
  df_cond_1 <- df_cond |>
    mutate(Regulation = case_when(
      logFC > lg2fc_p & FDR < p_adj ~ "UP",
      logFC < log2fc_n & FDR < p_adj ~ "DOWN",
      TRUE ~ "NO"
    )) |>
    mutate(Regulation = replace_na(Regulation, "NO")) |>
    mutate(HS = ifelse(FDR <= (df_cond |> arrange(FDR) |> slice_head(n = top_rows_to_select_genes) |> pull(FDR)), "YES", "NO"))
  
  p1 <- ggplot(data = df_cond_1, aes(x = logFC, y = -log10(FDR), col = Regulation)) +
    geom_jitter(position = position_jitter(height = 0.0000001, width = 0.0000001, seed = 123456), size = 1) +
    scale_color_manual(labels = c(down_e, "NO", up_e), values = c(colordown, "black", colorup)) +
    geom_vline(xintercept = c(-1, 1), col = "red") +
    geom_hline(yintercept = -log10(0.05), col = "red") +
    labs(title = title_) +
    xlim(-10, 10) +
    ylim(0, 5) +
    theme(panel.grid = element_blank(),
          panel.background = element_rect(fill = "transparent"),
          panel.border = element_rect(fill = "transparent"),
          legend.title = element_text(size = 7),
          legend.text = element_text(size = 7),
          axis.text = element_text(size = 7),
          axis.title = element_text(size = 7, face = "bold")) +
    geom_text_repel(data = df_cond_1, label = ifelse(df_cond_1$HS == "YES", as.character(df_cond_1$genes), ""),
                    color = "black", size = 2) +
    geom_point(position = position_jitter(height = 0.0000001, width = 0.0000001, seed = 123456), pch = 21, size = 1.1, color = "black",
               data = df_cond_1 |> filter(HS == "YES"), aes(x = logFC, y = -log10(FDR))) +
    geom_point(position = position_jitter(height = 0.0000001, width = 0.0000001, seed = 123456), pch = 21, size = 1.2, color = "black",
               data = df_cond_1 |> filter(HS == "YES"), aes(x = logFC, y = -log10(FDR)))
  
  return(list(plot = p1, data_volc = p1$data))
}
```


```{r,fig.height=4,fig.width=3}
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano <- volcano_plot_function(df_cond = pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table,
                                                                                  lg2fc_p = 1,log2fc_n = -1,
                                                                                  p_adj = 0.05,
                                                                                  top_rows_to_select_genes = 10,
                                                                                  title_= "Pellets Hip and Tibia Non-sclerotic vs Sclerotic",
                                                                                  colordown = "#999999",
                                                                                  down_e ="sclerotic",
                                                                                  up_e ="non.sclerotic",
                                                                                  colorup = "#E69F00")
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano
```


# personalized volcano


```{r,fig.width=4,fig.height=5}
# new "function"

# pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |>
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table |>
  dplyr::mutate(gene_type = dplyr::case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns"))


#max(without_wt_and_2_samples$log2FoldChange)
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |> dplyr::count(gene_type)



#Clean the predicted and cDNA RiK genes
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |>
  #dplyr::filter(!grepl(x = mgi_symbol,pattern = "^Gm\\d+")) |>
  #dplyr::filter(grepl(x = mgi_description,pattern = "predicted gene*")) |>
  #dplyr::filter(!grepl(x = mgi_symbol,pattern = "*Rik$")) |> 
  dplyr::filter(genes  != "")

write.table(x = pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod,
            file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Volcano/pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod_filtered_and_empty_values_in_external_gene_name.txt",
            sep = "\t",
            row.names = FALSE,
            col.names = TRUE)


# #interesting gene list
# lists_gata4_without_WT_and_G4RS13_and_G4RS21_deseq_anno_counts$TRANSHET_vs_HET |> filter(padj < 0.05 & abs(log2FoldChange) > 1) |> 
#   arrange(padj) |> slice_max(order_by = log2FoldChange,n = 25,with_ties = FALSE) |> pull(mgi_symbol)
# lists_gata4_without_WT_and_G4RS13_and_G4RS21_deseq_anno_counts$TRANSHET_vs_HET |> filter(padj < 0.05 & abs(log2FoldChange) > 1) |> 
#   arrange(padj) |> slice_min(order_by = log2FoldChange,n = 25,with_ties = FALSE) |> pull(mgi_symbol)

ints_up <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |>
  dplyr::filter(FDR < 0.05 & logFC >= 1) |> 
  dplyr::arrange(FDR) |>
  # dplyr::slice_max(padj + log2FoldChange,n = 10) |> 
  dplyr::slice(1:10) |> 
  dplyr::pull(genes)

ints_down <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |>
  dplyr::filter(FDR <= 0.05 & logFC <= -1) |> 
  dplyr::arrange(FDR) |>
  dplyr::slice(1:10) |> 
  # dplyr::slice_min(padj + log2FoldChange,n = 10) |>
  dplyr::pull(genes)

ints <- c(ints_up,ints_down)

ints_genes <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |> filter(genes %in% ints) |> dplyr::distinct(genes,.keep_all = TRUE)

ints_down <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |> filter(genes %in% ints_down) |> dplyr::distinct(genes,.keep_all = TRUE)

ints_up <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |> filter(genes %in% ints_up) |> dplyr::distinct(genes,.keep_all = TRUE)


#add special genes of interest

to_add_gene <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |> filter(genes == "COL7A1") 
to_add_gene$gene_type <- "ns"

pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod <- rbind(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod,to_add_gene)
ints_genes <- rbind(ints_genes,to_add_gene)


# Add colour, size and alpha (transparency) 
cols <- c("up" = "#ffad73", "down" = "#26b3ff", "ns" = "grey") 
sizes <- c("up" = 2, "down" = 2, "ns" = 1) 
alphas <- c("up" = 1, "down" = 1, "ns" = 0.5)



p1 <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |>
  ggplot(aes(x = logFC,
             y = -log10(FDR))) +
  geom_point(aes(colour = gene_type), 
             alpha = 0.8, 
             shape = 16,
             size = 1) +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") + 
  geom_vline(xintercept = c(log2(0.5), log2(2)),
             linetype = "dashed") +
  geom_point(data = ints_up,
             shape = 21,
             size = 2,
             fill = "tomato3", 
             colour = "black") + 
  geom_point(data = ints_down,
             shape = 21,
             size = 2,
             fill = "steelblue", 
             colour = "black") +
  geom_point(data = to_add_gene,
             shape = 21,
             size = 3,
             fill = "green", 
             colour = "black") +
  geom_label_repel(data = ints_genes, # Add labels last to appear as the top layer  
                   aes(label = genes),
                   force = 2,
                   nudge_y = .2,nudge_x = 0.1,
                   max.overlaps = 30,size = 2) +
  scale_colour_manual(values = cols) + 
  scale_x_continuous(breaks = c(seq(-10, 10, 2)),     
                     limits = c(-10, 10)) 

ggsave(plot = p1,
       filename = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Volcano/pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod_filtered_and_empty_values_in_external_gene_name.tiff",
       device = "tiff",
       dpi = 77,
       units = "in",
       width = 7,height = 12)

p1


```

```{r}
# Add colour, size and alpha (transparency) 
cols <- c("up" = "#ffad73", "down" = "#26b3ff", "ns" = "grey") 
sizes <- c("up" = 2, "down" = 2, "ns" = 1) 
alphas <- c("up" = 1, "down" = 1, "ns" = 0.5)



p2 <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod |>
  ggplot(aes(x = logFC,
             y = -log10(FDR))) +
  geom_point(aes(colour = gene_type), 
             alpha = 0.8, 
             shape = 16,
             size = 1) +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = c(log2(0.5), log2(2)),
             linetype = "dashed") +
  # geom_point(data = ints_up,
  #            shape = 21,
  #            size = 2,
  #            fill = "tomato3", 
  #            colour = "black") + 
  # geom_point(data = ints_down,
  #            shape = 21,
  #            size = 2,
  #            fill = "steelblue", 
  #            colour = "black") +
  # geom_point(data = to_add_gene,
  #            shape = 21,
  #            size = 3,
  #            fill = "blue", 
  #            colour = "black") +
  # geom_label_repel(data = ints_genes, # Add labels last to appear as the top layer  
  #                  aes(label = external_gene_name),
  #                  force = 2,
  #                  nudge_y = 1) +
  scale_colour_manual(values = cols) + 
  scale_x_continuous(breaks = c(seq(-10, 10, 2)),     
                     limits = c(-10, 10)) 


ggsave(plot = p2,
       filename = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Volcano/pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_volcano_mod_V2.svg",
       device = "svg",
       dpi = 77,
       units = "in",
       width = 7,height = 12)

p2
```
# Heatmap
```{r}
library(heatmaply)
library(dplyr)
library(RColorBrewer)

# Prepare the data
# pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table %>%
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table %>%

  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns"
  )) %>%
  filter(genes != "") %>%
  arrange(FDR) %>%
  slice_head(n = 500)

# Prepare the raw counts matrix
raw_counts <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap %>%
  select(starts_with("X"), genes) %>%
  # left_join(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$colsums_samples, by = "genes") %>%
  left_join(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$colsums_samples, by = "genes") %>%
  select(starts_with("X")) %>%
  as.matrix()

rownames(raw_counts) <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes



# Prepare the normalized counts matrix
# norm_counts_df <- as.data.frame(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$normalized_matrix)
norm_counts_df <- as.data.frame(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix)
norm_counts_df$genes <- rownames(norm_counts_df)
norm_counts <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap %>%
  select(starts_with("X"), genes) %>%
  left_join(norm_counts_df, by = "genes") %>%
  select(starts_with("X")) %>%
  as.matrix()

rownames(norm_counts) <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes
norm_counts <- na.omit(norm_counts)
```


# Raw counts
```{r}
# Define the color palette
my_palette <- rev(colorRampPalette(brewer.pal(11, "RdYlBu"))(256))

# Generate the heatmap
heatmaply(
  raw_counts,
  scale_fill_gradient_fun = scale_fill_gradientn(
    colours = c("#313695", "#4575B4", "#74ADD1", "#ABD9E9", "white", "#FDAE61", "#F46D43", "#D73027", "#A50026"),
    limits = c(-1, 1),
    values = scales::rescale(c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1))
  ),
  col_side_colors = tibble::tibble("<b>Column Names</b>" = md_df_bone %>% filter(tissue_celltype == "pellet") %>% pull(health_status)),
  col_side_palette = c("non.sclerotic" = "#E69F00", "sclerotic" = "#0673B3"),
  hide_colorbar = FALSE,
  showticklabels = TRUE,
  Rowv = TRUE,
  Colv = TRUE,
  plot_method = "ggplot",
  scale = "none",
  subplot_widths = c(0.2, 0.3),
  subplot_heights = c(0.1, 0.02, 0.88),
  key.title = "Expression Z-Score\nRaw Counts Values",
  grid_color = "white",
  grid_width = 0.71,
  fontsize_row = 7,
  hclust_method = "mcquitty",
  main = "pellets non.sclerotic vs sclerotic",
  file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Heatmaps/50_heatmap_plotly.html"
)

```

# Norm counts
```{r}
# Define the color palette
my_palette <- rev(colorRampPalette(brewer.pal(11, "RdYlBu"))(256))

# Generate the heatmap
heatmaply(
  norm_counts,
  scale_fill_gradient_fun = scale_fill_gradientn(
    colours = c("#313695", "#4575B4", "#74ADD1", "#ABD9E9", "white", "#FDAE61", "#F46D43", "#D73027", "#A50026"),
    limits = c(-1, 1),
    values = scales::rescale(c(-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1))
  ),
  col_side_colors = tibble::tibble("<b>Column Names</b>" = md_df_bone %>% filter(tissue_celltype == "pellet") %>% pull(health_status)),
  col_side_palette = c("non.sclerotic" = "#E69F00", "sclerotic" = "#0673B3"),
  hide_colorbar = FALSE,
  showticklabels = TRUE,
  Rowv = TRUE,
  Colv = TRUE,
  plot_method = "ggplot",
  scale = "none",
  subplot_widths = c(0.2, 0.3),
  subplot_heights = c(0.1, 0.02, 0.88),
  key.title = "Expression Z-Score\nNormalized Counts Values",
  grid_color = "white",
  grid_width = 0.71,
  fontsize_row = 7,
  hclust_method = "mcquitty",
  main = "pellets non.sclerotic vs sclerotic",
  file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Heatmaps/Norm_50_heatmap_plotly.html"
)

```
# Raw counts pheatmap
```{r}
library(ComplexHeatmap)
library(pheatmap)
library(svglite)
library(dplyr)

# Calculate Pearson correlation distance
distance.row <- as.dist(1 - cor(t(raw_counts)))
distance.col <- as.dist(1 - cor(raw_counts))

# Perform average linkage clustering
cluster.row <- hclust(distance.row, method = "average")
cluster.col <- hclust(distance.col, method = "average")

# Prepare annotation data
annotation_col <- as.data.frame(colnames(raw_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split the sample names into components
annotation_col <- annotation_col %>%
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")
annotation_col <- annotation_col %>% select(-ID, -tissue, -type)

# Merge with metadata
annotation_col <- annotation_col %>%
  left_join(md_df_bone %>% filter(tissue_celltype == "pellet"), by = c("sample_2" = "sampleID"))

# Select relevant columns
annotation_col <- annotation_col %>% dplyr::select(condition, Gender,)#Plate.ID_tissue, Age, Gender)

rownames(annotation_col) <- colnames(raw_counts)




# Define color palette
my_palette <- colorRampPalette(rev(brewer.pal(n = 58, name = "RdYlBu")))(256)

# Define annotation colors
annotation_colors <- list(
  condition = c("non.sclerotic" = "#E69F00", "sclerotic" = "#0673B3"),
  #Plate.ID_tissue = c("plate 1_tibia" = "#1f78b4", "plate 2_tibia" = "#33a02c", "plate 3_hip" = "#e31a1c"),
  Gender = c("M" = "#a6cee3", "F" = "#fb9a99")
)

# Print annotation_colors for debugging
print(annotation_colors)

# Generate the heatmap
pheatmap_raw_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic <- pheatmap(
  raw_counts,
  scale = "row",
  cluster_rows = cluster.row,
  cluster_cols = cluster.col,
  cellwidth = 12,
  cellheight = 9,
  breaks = seq(-1, 1, length.out = 101),
  annotation_col = annotation_col,
  annotation_colors = annotation_colors,
  filename = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Heatmaps/pheatmap_raw_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_pearson_corr_and_linkage_100_genes.png"
)

# Display the heatmap
pheatmap_raw_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic

```
# TODO change to logcpm
# Norm counts pheatmap
```{r}
library(ComplexHeatmap)
library(pheatmap)
library(svglite)
library(dplyr)

# Calculate Pearson correlation distance
distance.row <- as.dist(1 - cor(t(norm_counts)))
distance.col <- as.dist(1 - cor(norm_counts))

# Perform average linkage clustering
cluster.row <- hclust(distance.row, method = "average")
cluster.col <- hclust(distance.col, method = "average")

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split the sample names into components
annotation_col <- annotation_col %>%
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")
annotation_col <- annotation_col %>% select(-ID, -tissue, -type)

# Merge with metadata
annotation_col <- annotation_col %>%
  left_join(md_df_bone %>% filter(tissue_celltype == "pellet"), by = c("sample_2" = "sampleID"))

# Select relevant columns
annotation_col <- annotation_col %>% dplyr::select(condition, Gender,)#Plate.ID_tissue, Age, Gender)

rownames(annotation_col) <- colnames(norm_counts)




# Define color palette
my_palette <- colorRampPalette(rev(brewer.pal(n = 58, name = "RdYlBu")))(256)

# Define annotation colors
annotation_colors <- list(
  condition = c("non.sclerotic" = "#E69F00", "sclerotic" = "#0673B3"),
  #Plate.ID_tissue = c("plate 1_tibia" = "#1f78b4", "plate 2_tibia" = "#33a02c", "plate 3_hip" = "#e31a1c"),
  Gender = c("M" = "#a6cee3", "F" = "#fb9a99")
)

# Print annotation_colors for debugging
print(annotation_colors)

# Generate the heatmap
pheatmap_norm_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic <- pheatmap(
  norm_counts,
  scale = "row",
  cluster_rows = cluster.row,
  cluster_cols = cluster.col,
  cellwidth = 12,
  cellheight = 9,
  breaks = seq(-1, 1, length.out = 101),
  annotation_col = annotation_col,
  annotation_colors = annotation_colors,
  filename = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/pellets/Heatmaps/pheatmap_norm_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_pearson_corr_and_linkage_100_genes.png"
)

# Display the heatmap
pheatmap_norm_counts_pellets_hip_and_tibia_sclerotic_vs_non_sclerotic

```



# Model, try to predict condition (non.sclerotic vs sclerotic) using a model and the metadata.
# Randomforest first attempt
```{r,fig.height=4, fig.width=6}
library(randomForest)
library(caret)


library(heatmaply)
library(dplyr)
library(RColorBrewer)

# Prepare the data, we take either the top DEG or the most variable genes, or an intersection of those two.
#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> 
pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$results$table |>
  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns")) |>
  filter(genes != "") |> #,
         #FDR < 0.05) |> 
  arrange(FDR) |>
  slice_head(n = 500) #get top 500 DEG genes


# Prepare the dataset v2, select the most variable genes (top 1k): Variance-based selection (remove low-variance genes) use the normalized counts, so technical variability is removed.

pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix
# norm_matrix <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix
# # Calculate variance for each gene (row)
# gene_variances <- apply(norm_matrix, 1, var, na.rm = TRUE)
# 
# # Get the names of the top 2000 most variable genes
# top_1k_genes <- names(sort(gene_variances, decreasing = TRUE)[1:1000])
# 
# # Extract the subset matrix with only the top 1k most variable genes
# top_1k_matrix <- norm_matrix[top_1k_genes, ]
# # Check dimensions
# dim(top_1k_matrix)  # Should be [2000, number_of_samples]
# 
# # Optional: View the variance distribution
# summary(gene_variances)
# hist(gene_variances, main = "Distribution of Gene Variances", xlab = "Variance")
# 

gene_vars <- apply(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix,1 , var, na.rm = TRUE)
top_var_genes <- names(sort(gene_vars, decreasing = TRUE)[1:1000])  # Top 1000 most variable


# Prepare the top 1000 variable genes and the top 500 DEG.
# Combine approaches - intersection of variable and significant genes
selected_genes <- intersect(top_var_genes, pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes)
if(length(selected_genes) < 500) {
  # If intersection is too small, take union but limit to reasonable number
  selected_genes <- union(top_var_genes, pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes)#[1:min(1000, length(union(top_var_genes, pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes)))]
}
# Return all the unique values among both sides.
length(union(top_var_genes, pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes))

###########################################################################################################
# USE Normalized TMM data for RANDOM FOREST with the 1000 most variable genes and the top 500 DEG, union. #
##################################################################################################



# # Prepare the raw counts matrix
# raw_counts <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap |> 
#   #select(starts_with("X"), genes) |> 
#   select(genes) |> 
#   # left_join(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$colsums_samples, by = "genes") %>%
#   left_join(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$colsums_samples, by = "genes") |> 
# 
#   select(starts_with("X")) |> 
#   as.matrix()
# 
# rownames(raw_counts) <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes



# Prepare the normalized counts matrix
# norm_counts_df <- as.data.frame(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$normalized_matrix)
# norm_counts_df <- as.data.frame(pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix)
# norm_counts_df$genes <- rownames(norm_counts_df)
#dim(norm_counts_df)
#selected_genes <-data.frame(selected_genes,column="genes")
norm_counts <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic$normalized_matrix[selected_genes,]
  # select(starts_with("X")) |> 
  # as.matrix()
#rownames(norm_counts) <- pellets_hip_and_tibia_sclerotic_vs_non_sclerotic_heatmap$genes
norm_counts <- na.omit(norm_counts)
dim(norm_counts)




# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split the sample names into components
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")


####################################################################################################
# # Add oarsi scores, non.sclerotic and sclerotic samples have the same score!!!!!!!!!!!!!!!!!     #
####################################################################################################
# annotation_col <- annotation_col |>
#   left_join(oarsi_data_scores,by = c("ID" = "sampleID")) |>
#   mutate(oarsi = as.numeric(oarsi)) |>
#   mutate(oarsi = if_else(is.na(oarsi), 0, oarsi))
# 

# Add BMI,Age to samples
annotation_col <- annotation_col |> 
  # left_join(md_df[md_df$tissue_celltype_lowercase == "pellet",] [,c("sampleID","Plate.ID","nanodrop","a260.230","RIN...24","Age","Gender","BMI","Row.y","Column.y","sample_number")],by =c("sample_2"="sampleID"))
  left_join(md_df[,c("sampleID","Age","Gender","BMI")],by = c("sample_2"="sampleID"))

annotation_col <- annotation_col %>% select(-ID, -tissue, -type, -sample_2,)

# # Merge with metadata
# annotation_col <- annotation_col %>%
#   left_join(md_df_bone %>% filter(tissue_celltype == "pellet"), by = c("sample_2" = "sampleID"))
# 
# # Select relevant columns
# annotation_col <- annotation_col %>% dplyr::select(condition, Gender, oarsi,BMI )#Plate.ID_tissue, Age, Gender)barcodePlate.ID, X260.230.value..Nanodrop.,Concentration..ng.µL
# 
# rownames(annotation_col) <- colnames(norm_counts)




#combined_data <- cbind(t(raw_counts), annotation_col)
combined_data <- cbind(t(norm_counts), annotation_col)

#combined_data[,ncol(combined_data)]
# NO 
# NA VALUES NOT ALLOWED


# Alternatively, you can remove rows with missing values
# chec if any na..
any(is.na(combined_data))
sum(is.na(combined_data))
combined_data <- na.omit(combined_data)
dim(combined_data)
#column_to_remove <- "MAMDC2-AS1"
# combined_data <- combined_data %>% select(-all_of(column_to_remove))
# Replace all hyphens with dots in column names
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
# combined_data <- combined_data %>% select(-matches("AS1$"))
# combined_data <- combined_data %>% select(-matches("AS2$"))
# combined_data <- combined_data %>% select(-matches("IT1$"))
# combined_data <- combined_data %>% select(-matches("EGLN2$"))
# combined_data <- combined_data %>% select(-matches("-3$"))
dim(combined_data)



# ### Solve the issue with too many columns.... of the genes....
# combined_data <- combined_data[,c(1:5000,ncol(combined_data),(ncol(combined_data)-1),(ncol(combined_data)-2),(ncol(combined_data)-3))]


# Ensure the condition column is a factor
combined_data$condition <- factor(combined_data$condition)
#combined_data$oarsi <- as.factor(combined_data$oarsi)
# Split the data into training and testing sets
set.seed(123) # For reproducibility
trainIndex <- caret::createDataPartition(combined_data$condition, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- combined_data[trainIndex, ]
test_data <- combined_data[-trainIndex, ]

# Train a Random Forest model, using oarsi in the data
rf_model <- randomForest::randomForest(condition ~ ., data = train_data, importance = TRUE,ntree=10000)

# Predict on the test data
predictions <- predict(rf_model, test_data)

# Evaluate the model
caret::confusionMatrix(predictions, test_data$condition)

# Feature importance
randomForest::importance(rf_model)[order(randomForest::importance(rf_model)[,4],decreasing = TRUE),]
randomForest::varImpPlot(rf_model)

# Get importance scores
importance_scores <- importance(rf_model)
head(importance_scores[order(importance_scores[,1], decreasing = TRUE), ])

print(rf_model)
```

# Accuracy, features that hurt the most the model when removed (very important for the decissions)
# Gini, features that separate the best our classes.


```{r}
# Get top 10 most important features
top_10_features <- rownames(importance_scores)[order(importance_scores[,1], decreasing = TRUE)[1:10]]

cat("Top 10 most important features for predicting sclerosis:\n")
for(i in 1:10) {
  feature <- top_10_features[i]
  importance_val <- round(importance_scores[feature, 1], 3)
  cat(i, ".", feature, "- Importance:", importance_val, "\n")
}

# Check if clinical features are important
clinical_features <- c("BMI", "Age", "Gender")
clinical_ranks <- sapply(clinical_features, function(x) {
  which(rownames(importance_scores)[order(importance_scores[,1], decreasing = TRUE)] == x)
})
cat("\nClinical feature rankings:\n")
print(clinical_ranks)
```

# RF model with OARSI samples.

```{r}
####################################################################################################
# # Add oarsi scores, non.sclerotic and sclerotic samples have the same score!!!!!!!!!!!!!!!!!     #
####################################################################################################
## Load metadata of image scoring

.libPaths("/home/mbotos/CLUSTER/RLibs/")
library(readxl)
sclerotic_scores <- readxl::read_xlsx("/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/metadata/oarsi and oabs scoring .xlsx",sheet = "SC")
non_sclerotic_scores <- readxl::read_xlsx("/home/mbotos/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/metadata/oarsi and oabs scoring .xlsx",sheet = "NS ")
#Oarsi scoring
# 0 Normal
# 1 Small
# 2 Supeficial
# 3 25% arthrosis damage to the joint
# 4 50 %
# 5 75 %
# 6 >75%
```
# Use the features of inflammation, cysts... and so on not only the final oarsi score. oabs --> predictive score..
```{r}

```


# Extract and add the scores to the samples that have it.
```{r}
# Extract the row where 'oabs scoring' is 'OARSI scoring'
non_sclerotic_scores_vec <- non_sclerotic_scores  |>
  filter(`oabs scoring` == "OARSI scoring") |> 
  select(where(is.numeric)) |> 
  unlist(use.names = FALSE)

sclerotic_scores_vec <- sclerotic_scores  |>
  filter(`oabs scoring` == "OARSI scoring") |> 
  select(where(is.numeric)) |> 
  unlist(use.names = FALSE)

names(non_sclerotic_scores)
oarsi_data_scores <- data.frame(sampleID=paste0("X",names(non_sclerotic_scores)[2:length(names(non_sclerotic_scores))]),sclerotic_samples=sclerotic_scores_vec,non_sclerotic_samples=non_sclerotic_scores_vec)
```
```{r}
# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split the sample names into components
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")
# Add BMI,Age to samples

annotation_col_sc <- annotation_col |> 
  filter(condition=="sclerotic") |> 
  left_join(md_df |> 
              filter(health_status == "sclerotic",
                     tissue_celltype_lowercase == "pellet") |> 
              select("sampleID","Age","Gender","BMI"),#"Row.y","Column.y"),
            by = c("sample_2"="sampleID"))

annotation_col_sc
annotation_col_sc <- annotation_col_sc |>
  left_join(oarsi_data_scores |> 
              select(-non_sclerotic_samples),
            by=c("ID"="sampleID"))
annotation_col_sc
# Select only samples containing oarsi scores
annotation_col_sc <- annotation_col_sc |> 
  filter(!is.na(sclerotic_samples))
annotation_col_sc






annotation_col_nsc <- annotation_col |> 
  filter(condition == "non.sclerotic") |> 
  left_join(md_df |> 
              filter(health_status == "non.sclerotic",
                     tissue_celltype_lowercase == "pellet") |> 
              select("sampleID","Age","Gender","BMI"),#"Row.y","Column.y"),do not include position in the plate..
            by = c("sample_2"="sampleID"))
annotation_col_nsc

annotation_col_nsc <- annotation_col_nsc |>
  left_join(oarsi_data_scores |> 
              select(-sclerotic_samples),
            by=c("ID"="sampleID"))
annotation_col_nsc
# Select only samples containing oarsi scores
annotation_col_nsc <- annotation_col_nsc |> 
  filter(!is.na(non_sclerotic_samples))




annotation_col_oarsi_samples <- bind_rows(annotation_col_sc,annotation_col_nsc)
annotation_col_oarsi_samples
```

```{r,fig.height=4,fig.width=6}

#df$score <- ifelse(!is.na(df$score_a), df$score_a, df$score_b)
annotation_col_oarsi_samples <- annotation_col_oarsi_samples |> 
  mutate(oarsi_score = coalesce(sclerotic_samples,non_sclerotic_samples)) |> 
  select(-sclerotic_samples,-non_sclerotic_samples)
  

norm_counts_oarsi <-  norm_counts[,annotation_col_oarsi_samples$sample_2]
combined_data <- cbind(t(norm_counts_oarsi), annotation_col_oarsi_samples)
# NO -- NA -- VALUES NOT ALLOWED


# Alternatively, you can remove rows with missing values
# chec if any na..
any(is.na(combined_data))
sum(is.na(combined_data))
combined_data <- na.omit(combined_data)
dim(combined_data)
#column_to_remove <- "MAMDC2-AS1"
# combined_data <- combined_data %>% select(-all_of(column_to_remove))
# Replace all hyphens with dots in column names
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
# combined_data <- combined_data %>% select(-matches("AS1$"))
# combined_data <- combined_data %>% select(-matches("AS2$"))
# combined_data <- combined_data %>% select(-matches("IT1$"))
# combined_data <- combined_data %>% select(-matches("EGLN2$"))
# combined_data <- combined_data %>% select(-matches("-3$"))
combined_data <- combined_data |>  select(-type,-sample_2,-tissue)
dim(combined_data)



# ### Solve the issue with too many columns.... of the genes....
# combined_data <- combined_data[,c(1:5000,ncol(combined_data),(ncol(combined_data)-1),(ncol(combined_data)-2),(ncol(combined_data)-3))]


# Ensure the condition column is a factor
combined_data$condition <- as.factor(combined_data$condition)
combined_data$oarsi_score <- as.factor(combined_data$oarsi_score)
combined_data$Age <- as.factor(combined_data$Age)
combined_data$Gender <- as.factor(combined_data$Gender)
combined_data$BMI <- as.factor(combined_data$BMI)
#combined_data$Column.y <- as.factor(combined_data$Column.y)
#combined_data$Row.y <- as.factor(combined_data$Row.y)
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))

#combined_data$oarsi <- as.factor(combined_data$oarsi)
# Split the data into training and testing sets
set.seed(123) # For reproducibility
trainIndex <- caret::createDataPartition(combined_data$condition, p = .7, 
                                  list = FALSE, 
                                  times = 1)
train_data <- combined_data[trainIndex, ]
test_data <- combined_data[-trainIndex, ]
# Train rf model, excluding oarsi scores and see how does it affect.
# rf_model_oarsi <- randomForest::randomForest(condition ~ . - oarsi, data = train_data, importance = TRUE)
# Keep oarsi
rf_model_oarsi <- randomForest::randomForest(condition ~ ., data = train_data, importance = TRUE,ntree=10000)
# Predict on the test data
predictions <- predict(rf_model_oarsi, test_data)

# Evaluate the model
caret::confusionMatrix(predictions, test_data$condition)

# Feature importance
randomForest::importance(rf_model_oarsi)
randomForest::varImpPlot(rf_model_oarsi)

# Get importance scores
importance_scores <- importance(rf_model_oarsi)
head(importance_scores[order(importance_scores[,3], decreasing = TRUE), ])

print(rf_model)
```
```{r,fig.width=6,fig.height=8}
# Plot variable importance
randomForest::varImpPlot(rf_model_oarsi, main = "Variable Importance")

```
```{r}
# Get top 10 most important features
top_10_features <- rownames(importance_scores)[order(importance_scores[,1], decreasing = TRUE)[1:10]]

cat("Top 10 most important features for predicting sclerosis:\n")
for(i in 1:10) {
  feature <- top_10_features[i]
  importance_val <- round(importance_scores[feature, 1], 3)
  cat(i, ".", feature, "- Importance:", importance_val, "\n")
}

# Check if clinical features are important
clinical_features <- c("BMI", "Age", "Gender","oarsi_score")#,"Row.y","Column.y")
clinical_ranks <- sapply(clinical_features, function(x) {
  which(rownames(importance_scores)[order(importance_scores[,1], decreasing = TRUE)] == x)
})
cat("\nClinical feature rankings:\n")
print(clinical_ranks)
```

Gini: how goodd is the feature to split the trees...the highest the more important is the feature to obtain a pure split for the next decission.
MeanDecrease Accuracy: how important is the feature that if removed the model performs worst, the higher the more important.

```{r,fig.width=6,fig.height=8}
# Plot variable importance
randomForest::varImpPlot(rf_model, main = "Variable Importance")

```

```{r}
# Extract importance
importance <- randomForest::importance(rf_model)
importance_df <- data.frame(Feature = rownames(importance), Importance = importance[, "MeanDecreaseGini"])

# Plot top 20 important features
top_features <- importance_df %>% top_n(20, Importance)
ggplot(top_features, aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Important Features", x = "Features", y = "Importance")

```
```{r}
importance <- randomForest::importance(rf_model_oarsi)
importance_df <- data.frame(Feature = rownames(importance), Importance = importance[, "MeanDecreaseGini"])

# Plot top 20 important features
top_features <- importance_df %>% top_n(20, Importance)
ggplot(top_features, aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Important Features", x = "Features", y = "Importance")

```

# Hip adipocyte sclerotic vs non sclerotic RF.
```{r,fig.height=5, fig.width=6}
library(randomForest)
library(heatmaply)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(pheatmap)
library(corrplot)
library(pROC)
#library(caret)
library(VIM)
library(ROCR)
library(plotly)
library(viridis)
library(gridExtra)

# ================================================================
# DATA PREPARATION
# ================================================================

# Prepare the data - top DEG genes
hip_adipocytes_sclerotic_vs_non_sclerotic_heatmap <- hip_adipocytes_sclerotic_vs_non_sclerotic$results$table |>
  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns")) |>
  filter(genes != "") |>
  arrange(FDR) |>
  slice_head(n = 500) # Top 500 DEG genes

# Get most variable genes (top 1k)
gene_vars <- apply(hip_adipocytes_sclerotic_vs_non_sclerotic$normalized_matrix, 1, var, na.rm = TRUE)
top_var_genes <- names(sort(gene_vars, decreasing = TRUE)[1:1000])

# Combine approaches - union of variable and significant genes
selected_genes <- union(top_var_genes, hip_adipocytes_sclerotic_vs_non_sclerotic_heatmap$genes)

cat("Selected genes:", length(selected_genes), "\n")
cat("Top variable genes:", length(top_var_genes), "\n")
cat("Top DEG genes:", length(hip_adipocytes_sclerotic_vs_non_sclerotic_heatmap$genes), "\n")

# Prepare normalized counts matrix
norm_counts <- hip_adipocytes_sclerotic_vs_non_sclerotic$normalized_matrix[selected_genes,]
norm_counts <- na.omit(norm_counts)

cat("Matrix dimensions after filtering:", dim(norm_counts), "\n")


# ================================================================
# SAMPLE ANNOTATION AND METADATA PREPARATION
# ================================================================

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# Add metadata (BMI, Age, Gender)
annotation_col <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

# Combine data
combined_data <- cbind(t(norm_counts), annotation_col)

# Clean data
combined_data <- na.omit(combined_data)
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
combined_data$condition <- as.factor(combined_data$condition)

cat("Final combined data dimensions:", dim(combined_data), "\n")

# ================================================================
# TRAIN-TEST SPLIT (Patient-wise to avoid data leakage)
# ================================================================

# Patient-wise splitting
samples_per_patient <- table(md_df$sample_number)
paired_patients <- names(samples_per_patient)[samples_per_patient == 4]

set.seed(123)
train_proportion <- 0.7
n_train_patients <- round(length(paired_patients) * train_proportion)

train_patient_ids <- sample(paired_patients, n_train_patients)
test_patient_ids <- setdiff(paired_patients, train_patient_ids)

# Create train/test datasets
train_data <- combined_data[md_df$sample_number %in% train_patient_ids,]
test_data <- combined_data[md_df$sample_number %in% test_patient_ids,]

train_data_clean <- train_data[rowSums(is.na(train_data)) != ncol(train_data), ]
test_data_clean <- test_data[rowSums(is.na(test_data)) != ncol(test_data), ]

cat("Training samples:", nrow(train_data_clean), "\n")
cat("Test samples:", nrow(test_data_clean), "\n")
cat("Training patients:", length(train_patient_ids), "\n")
cat("Test patients:", length(test_patient_ids), "\n")

# Check condition distribution
cat("\nTraining set condition distribution:\n")
print(table(train_data_clean$condition))
cat("\nTest set condition distribution:\n")
print(table(test_data_clean$condition))

# ================================================================
# VISUALIZATION 1: DATA OVERVIEW AND QUALITY CHECK
# ================================================================

# Plot 1: Sample distribution
p1 <- ggplot(combined_data, aes(x = condition, fill = condition)) +
  geom_bar(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Sample Distribution by Condition",
       x = "Condition", y = "Number of Samples") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 2: Age distribution by condition
p2 <- ggplot(combined_data, aes(x = condition, y = Age, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Age Distribution by Condition",
       x = "Condition", y = "Age") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 3: BMI distribution by condition
p3 <- ggplot(combined_data, aes(x = condition, y = BMI, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "BMI Distribution by Condition",
       x = "Condition", y = "BMI") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 4: Gender distribution
p4 <- ggplot(combined_data, aes(x = condition, fill = Gender)) +
  geom_bar(position = "dodge", alpha = 0.7) +
  scale_fill_brewer(palette = "Dark2") +
  labs(title = "Gender Distribution by Condition",
       x = "Condition", y = "Count") +
  theme_minimal()

grid.arrange(p1, p2, p3, p4, ncol = 2, nrow = 2)

# Visu
train_data_clean[,c(1400:1412)]

# ================================================================
# RANDOM FOREST MODEL TRAINING
# ================================================================
# Train Random Forest model with more detailed parameters

rf_model <- randomForest(formula = condition ~ .,
                         data = train_data_clean,
                         importance = TRUE,
                         ntree = 9*ncol(train_data_clean),
                         mtry = sqrt(ncol(train_data_clean)-4), # Approximately sqrt of features
                         do.trace = 100,
                         proximity = TRUE,
                         keep.forest = TRUE
                         )

print(rf_model)

# ================================================================
# VISUALIZATION 2: MODEL PERFORMANCE METRICS
# ================================================================

# Predictions
train_predictions <- predict(rf_model, train_data_clean, type = "response")
test_predictions <- predict(rf_model, test_data_clean, type = "response")

train_probs <- predict(rf_model, train_data_clean, type = "prob")
test_probs <- predict(rf_model, test_data_clean, type = "prob")

# Confusion Matrices
train_cm <- caret::confusionMatrix(train_predictions, train_data_clean$condition)
test_cm <- caret::confusionMatrix(test_predictions, test_data_clean$condition)

print("Training Set Performance:")
print(train_cm)
print("\nTest Set Performance:")
print(test_cm)

# Plot 5: Confusion Matrix Heatmaps
train_cm_df <- as.data.frame(train_cm$table)
test_cm_df <- as.data.frame(test_cm$table)

p5 <- ggplot(train_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Training Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

p6 <- ggplot(test_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Test Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

grid.arrange(p5, p6, ncol = 2)

# ================================================================
# VISUALIZATION 3: ROC CURVES AND AUC
# ================================================================

# ROC Analysis
if(ncol(train_probs) >= 2) {
  # Training ROC
  train_roc <- roc(train_data_clean$condition, train_probs[,2])
  test_roc <- roc(test_data_clean$condition, test_probs[,2])
  
  # Plot ROC curves
  plot(train_roc, main = "ROC Curves Comparison", 
       col = "blue", lwd = 2)
  plot(test_roc, add = TRUE, col = "red", lwd = 2)
  legend("bottomright", 
         legend = c(paste("Training AUC =", round(train_roc$auc, 3)),
                   paste("Test AUC =", round(test_roc$auc, 3))),
         col = c("blue", "red"), lwd = 2)
  
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

# ================================================================
# VISUALIZATION 4: VARIABLE IMPORTANCE
# ================================================================

# Get importance measures
importance_df <- data.frame(
  Gene = rownames(rf_model$importance),
  MeanDecreaseAccuracy = rf_model$importance[,3],
  MeanDecreaseGini = rf_model$importance[,4]
) |>
  arrange(desc(MeanDecreaseAccuracy))

# Plot 7: Top 20 Important Features - Mean Decrease Accuracy
p7 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Accuracy)",
       x = "Genes", y = "Mean Decrease Accuracy") +
  theme_minimal()

# Plot 8: Top 20 Important Features - Mean Decrease Gini
p8 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_col(fill = "darkgreen", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Gini)",
       x = "Genes", y = "Mean Decrease Gini") +
  theme_minimal()

grid.arrange(p7, p8, ncol = 1)

# Plot importance using randomForest's built-in function
varImpPlot(rf_model, main = "Variable Importance Plot")

# ================================================================
# VISUALIZATION 5: MODEL DIAGNOSTICS
# ================================================================

# Plot 9: Error Rate vs Number of Trees
plot(rf_model, main = "Error Rate vs Number of Trees")
legend("topright", legend = c("OOB", levels(train_data_clean$condition)), 
       col = 1:(length(levels(train_data_clean$condition))+1), lty = 1)

# Plot 10: Out-of-Bag Error Rate
oob_error <- rf_model$err.rate[,1]
p10 <- data.frame(Trees = 1:length(oob_error), OOB_Error = oob_error) |>
  ggplot(aes(x = Trees, y = OOB_Error)) +
  geom_line(color = "red", size = 1) +
  labs(title = "Out-of-Bag Error Rate vs Number of Trees",
       x = "Number of Trees", y = "OOB Error Rate") +
  theme_minimal()

print(p10)

# ================================================================
# VISUALIZATION 6: MULTIDIMENSIONAL SCALING (MDS) PLOT
# ================================================================
library(MASS)
library(ggplot2)
library(gridExtra)

# MDS plot using proximity matrix, value of distances is more important than the "rank"  (better for interpretation)
if (!is.null(rf_model$proximity)) {
  dist_mat <- 1 - rf_model$proximity
  
  # Classical MDS (metric)
  mds_metric <- cmdscale(dist_mat, k = 2)
  mds_metric_df <- data.frame(
    MDS1 = mds_metric[, 1],
    MDS2 = mds_metric[, 2],
    Condition = train_data_clean$condition,
    Predicted = train_predictions
  )
  
  # Non-metric MDS, rank of distances is more important than the actual values for the proximity 
  # Very useful when your distances are semantic, ordinal, or not reliable in scale (random forest values...) semantic
  # very useful for rf results visu
  mds_nonmetric <- isoMDS(dist_mat, k = 2)
  mds_nonmetric_df <- data.frame(
    MDS1 = mds_nonmetric$points[, 1],
    MDS2 = mds_nonmetric$points[, 2],
    Condition = train_data_clean$condition,
    Predicted = train_predictions
  )
  
  # Plot 11: Classical MDS - colored by actual condition
  p11 <- ggplot(mds_metric_df, aes(x = MDS1, y = MDS2, color = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Set1") +
    labs(title = "Classical MDS - Colored by Condition",
         x = "MDS Dim 1", y = "MDS Dim 2") +
    theme_minimal()
  
  # Plot 12: Classical MDS - colored by predictions
  p12 <- ggplot(mds_metric_df, aes(x = MDS1, y = MDS2, color = Predicted, shape = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = "Classical MDS - Predictions vs Condition",
         x = "MDS Dim 1", y = "MDS Dim 2") +
    theme_minimal()
  
  # Plot 13: Non-metric MDS - colored by actual condition
  p13 <- ggplot(mds_nonmetric_df, aes(x = MDS1, y = MDS2, color = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Set1") +
    labs(title = "Non-metric MDS - Colored by Condition",
         x = "MDS Dim 1", y = "MDS Dim 2") +
    theme_minimal()
  
  # Plot 14: Non-metric MDS - colored by predictions
  p14 <- ggplot(mds_nonmetric_df, aes(x = MDS1, y = MDS2, color = Predicted, shape = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = "Non-metric MDS - Predictions vs Condition",
         x = "MDS Dim 1", y = "MDS Dim 2") +
    theme_minimal()
  
  # Display all four plots in a 2x2 grid
  grid.arrange(p11, p12, p13, p14, ncol = 2)
}

# ================================================================
# VISUALIZATION 7: GENE EXPRESSION HEATMAP
# ================================================================

# Create heatmap of top important genes
top_genes <- importance_df$Gene[1:50]  # Top 50 most important genes
valid_genes <- top_genes[top_genes %in% rownames(norm_counts)]
heatmap_data <- norm_counts[valid_genes, ]

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# safety colname 
#annotation_col_rownames_safety_check <- annotation_col$sample_2
# Add metadata (BMI, Age, Gender)
heatmap_annotation <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

rownames(heatmap_annotation) <- colnames(heatmap_data)

# Create heatmap
pheatmap(
  heatmap_data,
  annotation_col = heatmap_annotation,
  scale = "row",
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  show_rownames = TRUE,
  show_colnames = FALSE,
  main = "Heatmap of Top 50 Most Important Genes",
  fontsize_row = 6,
  color = colorRampPalette(c("blue", "white", "red"))(100)
)

# ================================================================
# VISUALIZATION 8: PARTIAL DEPENDENCE PLOTS
# ================================================================

# Partial dependence plots for top 6 genes
top_6_genes <- importance_df$Gene[1:6]

par(mfrow = c(2, 3))
for(gene in top_6_genes) {
  partialPlot(rf_model, train_data_clean, x.var = paste0(gene), main = paste("Partial Dependence:", gene))
}
par(mfrow = c(1, 1))

# ================================================================
# COMPREHENSIVE MODEL SUMMARY AND INTERPRETATION
# ================================================================


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("COMPREHENSIVE RANDOM FOREST MODEL ANALYSIS SUMMARY\n")
cat("\n", paste(rep("=", 80), collapse = ""), "\n")

cat("\n1. DATA OVERVIEW:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Total samples:", nrow(combined_data), "\n")
cat("- Total features (genes):", ncol(combined_data) - 4, "\n")
cat("- Training samples:", nrow(train_data_clean), "\n")
cat("- Test samples:", nrow(test_data_clean), "\n")
cat("- Class distribution (overall):", table(combined_data$condition), "\n")

cat("\n2. MODEL CONFIGURATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Number of trees:", rf_model$ntree, "\n")
cat("- Features per split (mtry):", rf_model$mtry, "\n")
cat("- OOB Error Rate:", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), "%\n")

cat("\n3. PERFORMANCE METRICS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("Training Accuracy:", round(train_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Test Accuracy:", round(test_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Training Sensitivity:", round(train_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Test Sensitivity:", round(test_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Training Specificity:", round(train_cm$byClass['Specificity'] * 100, 2), "%\n")
cat("Test Specificity:", round(test_cm$byClass['Specificity'] * 100, 2), "%\n")

if(exists("train_roc")) {
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

cat("\n4. TOP 10 MOST IMPORTANT GENES:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
for(i in 1:10) {
  cat(sprintf("%2d. %s (MDA: %.4f, MDG: %.4f)\n", 
              i, importance_df$Gene[i], 
              importance_df$MeanDecreaseAccuracy[i],
              importance_df$MeanDecreaseGini[i]))
}

cat("\n5. MODEL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- The Random Forest model shows", 
    ifelse(test_cm$overall['Accuracy'] > 0.8, "excellent", 
           ifelse(test_cm$overall['Accuracy'] > 0.7, "good", "moderate")), 
    "predictive performance\n")

cat("- OOB error of", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), 
    "% indicates", 
    ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.1, "excellent", 
           ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.2, "good", "moderate")),
    "model generalization\n")

if(exists("test_roc")) {
  cat("- AUC of", round(test_roc$auc, 3), "suggests", 
      ifelse(test_roc$auc > 0.9, "excellent", 
             ifelse(test_roc$auc > 0.8, "good", "fair")), 
      "discriminative ability\n")
}

cat("- The top important genes likely represent key biomarkers\n")
cat("  distinguishing sclerotic from non-sclerotic conditions\n")

cat("\n6. BIOLOGICAL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Gene expression patterns successfully differentiate conditions\n")
cat("- Important genes may be involved in:\n")
# cat("  * Bone remodeling and sclerosis pathways\n")
# cat("  * Inflammatory responses\n")
# cat("  * Extracellular matrix regulation\n")
# cat("  * Adipocyte differentiation and function\n")
# Add enrichR results top 3 pathwas gobp, kegg and reactome.
# Perform enrichR
#install.packages("enrichR")
library(enrichR)
websiteLive <- getOption("enrichR.live")
if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr") # Human genes   
}
if (websiteLive) dbs <- listEnrichrDbs()
#dbs <- listEnrichrDbs()
dbs

#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> dplyr::filter(FDR < 0.05)
hip_adipocytes_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05)


message(paste0("Working on sample: ",hip_adipocytes_sclerotic_vs_non_sclerotic$name))

dbs <- c('GO_Cellular_Component_2017','GO_Molecular_Function_2017','GO_Biological_Process_2017','CellMarker_2024')
enriched <- enrichr(genes = c(hip_adipocytes_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05) |> 
                      #dplyr::filter(!grepl(x = genes,pattern = "^Gm\\d+")) |>
                      #dplyr::filter(!grepl(x = genes,pattern = "*Rik$")) |> 
                      dplyr::filter(!is.na(genes)) |> 
                      dplyr::filter(genes != "") |>
                      dplyr::filter(!grepl(x = genes, pattern = "ENSG")) |>
                      dplyr::pull(genes)), databases = dbs)

enriched

enriched[["CellMarker_2024"]]
# plot the enrichment 3 from dbs GOBP

#enriched
#enriched$CellMarker_2024
write.table(enriched[["CellMarker_2024"]],file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/hip_patient/HSA_vs_HNSA_enriched_papers_enrichR.csv",
            sep = ",",row.names = FALSE,col.names = TRUE)
plotEnrich(enriched[[4]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")



cat("\n7. RECOMMENDATIONS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Validate top biomarker genes in independent cohorts\n")
cat("- Investigate biological pathways of important genes\n")
cat("- Consider ensemble methods for improved performance\n")
cat("- Perform functional enrichment analysis of top genes\n")

cat("\n", paste(rep("=", 80), collapse = ""), "\n")
```

# Hip pellet sclerotic vs non sclerotic RF.
```{r,fig.height=5, fig.width=6}
library(randomForest)
library(heatmaply)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(pheatmap)
library(corrplot)
library(pROC)
#library(caret)
library(VIM)
library(ROCR)
library(plotly)
library(viridis)
library(gridExtra)

# ================================================================
# DATA PREPARATION
# ================================================================

# Prepare the data - top DEG genes
hip_pellet_sclerotic_vs_non_sclerotic_heatmap <- hip_pellet_sclerotic_vs_non_sclerotic$results$table |>
  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns")) |>
  filter(genes != "") |>
  arrange(FDR) |>
  slice_head(n = 500) # Top 500 DEG genes

# Get most variable genes (top 1k)
gene_vars <- apply(hip_pellet_sclerotic_vs_non_sclerotic$normalized_matrix, 1, var, na.rm = TRUE)
top_var_genes <- names(sort(gene_vars, decreasing = TRUE)[1:1000])

# Combine approaches - union of variable and significant genes
selected_genes <- union(top_var_genes, hip_pellet_sclerotic_vs_non_sclerotic_heatmap$genes)

cat("Selected genes:", length(selected_genes), "\n")
cat("Top variable genes:", length(top_var_genes), "\n")
cat("Top DEG genes:", length(hip_pellet_sclerotic_vs_non_sclerotic_heatmap$genes), "\n")

# Prepare normalized counts matrix
norm_counts <- hip_pellet_sclerotic_vs_non_sclerotic$normalized_matrix[selected_genes,]
norm_counts <- na.omit(norm_counts)

cat("Matrix dimensions after filtering:", dim(norm_counts), "\n")


# ================================================================
# SAMPLE ANNOTATION AND METADATA PREPARATION
# ================================================================

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# Add metadata (BMI, Age, Gender)
annotation_col <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

# Combine data
combined_data <- cbind(t(norm_counts), annotation_col)

# Clean data
combined_data <- na.omit(combined_data)
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
combined_data$condition <- as.factor(combined_data$condition)

cat("Final combined data dimensions:", dim(combined_data), "\n")

# ================================================================
# TRAIN-TEST SPLIT (Patient-wise to avoid data leakage)
# ================================================================

# Patient-wise splitting
samples_per_patient <- table(md_df$sample_number)
paired_patients <- names(samples_per_patient)[samples_per_patient == 4]

set.seed(123)
train_proportion <- 0.7
n_train_patients <- round(length(paired_patients) * train_proportion)

train_patient_ids <- sample(paired_patients, n_train_patients)
test_patient_ids <- setdiff(paired_patients, train_patient_ids)

# Create train/test datasets
train_data <- combined_data[md_df$sample_number %in% train_patient_ids,]
test_data <- combined_data[md_df$sample_number %in% test_patient_ids,]

train_data_clean <- train_data[rowSums(is.na(train_data)) != ncol(train_data), ]
test_data_clean <- test_data[rowSums(is.na(test_data)) != ncol(test_data), ]

cat("Training samples:", nrow(train_data_clean), "\n")
cat("Test samples:", nrow(test_data_clean), "\n")
cat("Training patients:", length(train_patient_ids), "\n")
cat("Test patients:", length(test_patient_ids), "\n")

# Check condition distribution
cat("\nTraining set condition distribution:\n")
print(table(train_data_clean$condition))
cat("\nTest set condition distribution:\n")
print(table(test_data_clean$condition))

# ================================================================
# VISUALIZATION 1: DATA OVERVIEW AND QUALITY CHECK
# ================================================================

# Plot 1: Sample distribution
p1 <- ggplot(combined_data, aes(x = condition, fill = condition)) +
  geom_bar(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Sample Distribution by Condition",
       x = "Condition", y = "Number of Samples") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 2: Age distribution by condition
p2 <- ggplot(combined_data, aes(x = condition, y = Age, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Age Distribution by Condition",
       x = "Condition", y = "Age") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 3: BMI distribution by condition
p3 <- ggplot(combined_data, aes(x = condition, y = BMI, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "BMI Distribution by Condition",
       x = "Condition", y = "BMI") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 4: Gender distribution
p4 <- ggplot(combined_data, aes(x = condition, fill = Gender)) +
  geom_bar(position = "dodge", alpha = 0.7) +
  scale_fill_brewer(palette = "Dark2") +
  labs(title = "Gender Distribution by Condition",
       x = "Condition", y = "Count") +
  theme_minimal()

grid.arrange(p1, p2, p3, p4, ncol = 2, nrow = 2)

# Visu
train_data_clean[,c((ncol(train_data_clean)-5):ncol(train_data_clean))]

# ================================================================
# RANDOM FOREST MODEL TRAINING
# ================================================================
# Train Random Forest model with more detailed parameters

rf_model <- randomForest(formula = condition ~ .,
                         data = train_data_clean,
                         importance = TRUE,
                         ntree = 9*ncol(train_data_clean),
                         mtry = sqrt(ncol(train_data_clean)-4), # Approximately sqrt of features
                         do.trace = 100,
                         proximity = TRUE,
                         keep.forest = TRUE
                         )

print(rf_model)

# ================================================================
# VISUALIZATION 2: MODEL PERFORMANCE METRICS
# ================================================================

# Predictions
train_predictions <- predict(rf_model, train_data_clean, type = "response")
test_predictions <- predict(rf_model, test_data_clean, type = "response")

train_probs <- predict(rf_model, train_data_clean, type = "prob")
test_probs <- predict(rf_model, test_data_clean, type = "prob")

# Confusion Matrices
train_cm <- caret::confusionMatrix(train_predictions, train_data_clean$condition)
test_cm <- caret::confusionMatrix(test_predictions, test_data_clean$condition)

print("Training Set Performance:")
print(train_cm)
print("\nTest Set Performance:")
print(test_cm)

# Plot 5: Confusion Matrix Heatmaps
train_cm_df <- as.data.frame(train_cm$table)
test_cm_df <- as.data.frame(test_cm$table)

p5 <- ggplot(train_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Training Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

p6 <- ggplot(test_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Test Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

grid.arrange(p5, p6, ncol = 2)

# ================================================================
# VISUALIZATION 3: ROC CURVES AND AUC
# ================================================================

# ROC Analysis
if(ncol(train_probs) >= 2) {
  # Training ROC
  train_roc <- roc(train_data_clean$condition, train_probs[,2])
  test_roc <- roc(test_data_clean$condition, test_probs[,2])
  
  # Plot ROC curves
  plot(train_roc, main = "ROC Curves Comparison", 
       col = "blue", lwd = 2)
  plot(test_roc, add = TRUE, col = "red", lwd = 2)
  legend("bottomright", 
         legend = c(paste("Training AUC =", round(train_roc$auc, 3)),
                   paste("Test AUC =", round(test_roc$auc, 3))),
         col = c("blue", "red"), lwd = 2)
  
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

# ================================================================
# VISUALIZATION 4: VARIABLE IMPORTANCE
# ================================================================

# Get importance measures
importance_df <- data.frame(
  Gene = rownames(rf_model$importance),
  MeanDecreaseAccuracy = rf_model$importance[,3],
  MeanDecreaseGini = rf_model$importance[,4]
) |>
  arrange(desc(MeanDecreaseAccuracy))

# Plot 7: Top 20 Important Features - Mean Decrease Accuracy
p7 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Accuracy)",
       x = "Genes", y = "Mean Decrease Accuracy") +
  theme_minimal()

# Plot 8: Top 20 Important Features - Mean Decrease Gini
p8 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_col(fill = "darkgreen", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Gini)",
       x = "Genes", y = "Mean Decrease Gini") +
  theme_minimal()

grid.arrange(p7, p8, ncol = 1)

# Plot importance using randomForest's built-in function
varImpPlot(rf_model, main = "Variable Importance Plot")

# ================================================================
# VISUALIZATION 5: MODEL DIAGNOSTICS
# ================================================================

# Plot 9: Error Rate vs Number of Trees
plot(rf_model, main = "Error Rate vs Number of Trees")
legend("topright", legend = c("OOB", levels(train_data_clean$condition)), 
       col = 1:(length(levels(train_data_clean$condition))+1), lty = 1)

# Plot 10: Out-of-Bag Error Rate
oob_error <- rf_model$err.rate[,1]
p10 <- data.frame(Trees = 1:length(oob_error), OOB_Error = oob_error) |>
  ggplot(aes(x = Trees, y = OOB_Error)) +
  geom_line(color = "red", size = 1) +
  labs(title = "Out-of-Bag Error Rate vs Number of Trees",
       x = "Number of Trees", y = "OOB Error Rate") +
  theme_minimal()

print(p10)

# ================================================================
# VISUALIZATION 6: MULTIDIMENSIONAL SCALING (MDS) PLOT
# ================================================================

# MDS plot using proximity matrix
if(!is.null(rf_model$proximity)) {
  mds_result <- cmdscale(1 - rf_model$proximity, k = 2)
  mds_df <- data.frame(
    MDS1 = mds_result[,1],
    MDS2 = mds_result[,2],
    Condition = train_data_clean$condition,
    Predicted = train_predictions
  )
  
  # Plot 11: MDS plot colored by actual condition
  p11 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Set1") +
    labs(title = "MDS Plot - Colored by Actual Condition",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  # Plot 12: MDS plot colored by predictions
  p12 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Predicted, 
                           shape = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = "MDS Plot - Predictions vs Actual (Shape = Actual)",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  grid.arrange(p11, p12, ncol = 2)
}

# ================================================================
# VISUALIZATION 7: GENE EXPRESSION HEATMAP
# ================================================================

# Create heatmap of top important genes
top_genes <- importance_df$Gene[1:50]  # Top 50 most important genes
valid_genes <- top_genes[top_genes %in% rownames(norm_counts)]
heatmap_data <- norm_counts[valid_genes, ]

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# safety colname 
#annotation_col_rownames_safety_check <- annotation_col$sample_2
# Add metadata (BMI, Age, Gender)
heatmap_annotation <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

rownames(heatmap_annotation) <- colnames(heatmap_data)

# Create heatmap
pheatmap(
  heatmap_data,
  annotation_col = heatmap_annotation,
  scale = "row",
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  show_rownames = TRUE,
  show_colnames = FALSE,
  main = "Heatmap of Top 50 Most Important Genes",
  fontsize_row = 6,
  color = colorRampPalette(c("blue", "white", "red"))(100)
)

# ================================================================
# VISUALIZATION 8: PARTIAL DEPENDENCE PLOTS
# ================================================================

# Partial dependence plots for top 6 genes
top_6_genes <- importance_df$Gene[1:6]

par(mfrow = c(2, 3))
for(gene in top_6_genes) {
  partialPlot(rf_model, train_data_clean, x.var = paste0(gene), main = paste("Partial Dependence:", gene))
}
par(mfrow = c(1, 1))

# ================================================================
# COMPREHENSIVE MODEL SUMMARY AND INTERPRETATION
# ================================================================


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("COMPREHENSIVE RANDOM FOREST MODEL ANALYSIS SUMMARY\n")
cat("\n", paste(rep("=", 80), collapse = ""), "\n")

cat("\n1. DATA OVERVIEW:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Total samples:", nrow(combined_data), "\n")
cat("- Total features (genes):", ncol(combined_data) - 4, "\n")
cat("- Training samples:", nrow(train_data_clean), "\n")
cat("- Test samples:", nrow(test_data_clean), "\n")
cat("- Class distribution (overall):", table(combined_data$condition), "\n")

cat("\n2. MODEL CONFIGURATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Number of trees:", rf_model$ntree, "\n")
cat("- Features per split (mtry):", rf_model$mtry, "\n")
cat("- OOB Error Rate:", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), "%\n")

cat("\n3. PERFORMANCE METRICS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("Training Accuracy:", round(train_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Test Accuracy:", round(test_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Training Sensitivity:", round(train_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Test Sensitivity:", round(test_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Training Specificity:", round(train_cm$byClass['Specificity'] * 100, 2), "%\n")
cat("Test Specificity:", round(test_cm$byClass['Specificity'] * 100, 2), "%\n")

if(exists("train_roc")) {
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

cat("\n4. TOP 10 MOST IMPORTANT GENES:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
for(i in 1:10) {
  cat(sprintf("%2d. %s (MDA: %.4f, MDG: %.4f)\n", 
              i, importance_df$Gene[i], 
              importance_df$MeanDecreaseAccuracy[i],
              importance_df$MeanDecreaseGini[i]))
}

cat("\n5. MODEL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- The Random Forest model shows", 
    ifelse(test_cm$overall['Accuracy'] > 0.8, "excellent", 
           ifelse(test_cm$overall['Accuracy'] > 0.7, "good", "moderate")), 
    "predictive performance\n")

cat("- OOB error of", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), 
    "% indicates", 
    ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.1, "excellent", 
           ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.2, "good", "moderate")),
    "model generalization\n")

if(exists("test_roc")) {
  cat("- AUC of", round(test_roc$auc, 3), "suggests", 
      ifelse(test_roc$auc > 0.9, "excellent", 
             ifelse(test_roc$auc > 0.8, "good", "fair")), 
      "discriminative ability\n")
}

cat("- The top important genes likely represent key biomarkers\n")
cat("  distinguishing sclerotic from non-sclerotic conditions\n")

cat("\n6. BIOLOGICAL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Gene expression patterns successfully differentiate conditions\n")
cat("- Important genes may be involved in:\n")
# cat("  * Bone remodeling and sclerosis pathways\n")
# cat("  * Inflammatory responses\n")
# cat("  * Extracellular matrix regulation\n")
# cat("  * Adipocyte differentiation and function\n")
# Add enrichR results top 3 pathwas gobp, kegg and reactome.
# Perform enrichR
#install.packages("enrichR")
library(enrichR)
websiteLive <- getOption("enrichR.live")
if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr") # Human genes   
}
if (websiteLive) dbs <- listEnrichrDbs()
#dbs <- listEnrichrDbs()
dbs

#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> dplyr::filter(FDR < 0.05)
hip_pellet_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05)


message(paste0("Working on sample: ",hip_pellet_sclerotic_vs_non_sclerotic$name))

dbs <- c('GO_Cellular_Component_2017','GO_Molecular_Function_2017','GO_Biological_Process_2017','CellMarker_2024')
enriched <- enrichr(genes = c(hip_pellet_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05) |> 
                      #dplyr::filter(!grepl(x = genes,pattern = "^Gm\\d+")) |>
                      #dplyr::filter(!grepl(x = genes,pattern = "*Rik$")) |> 
                      dplyr::filter(!is.na(genes)) |> 
                      dplyr::filter(genes != "") |>
                      dplyr::filter(!grepl(x = genes, pattern = "ENSG")) |>
                      dplyr::pull(genes)), databases = dbs)

enriched

enriched[["CellMarker_2024"]]
# plot the enrichment 3 from dbs GOBP

#enriched
#enriched$CellMarker_2024
write.table(enriched[["CellMarker_2024"]],file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/hip_patient/HSP_vs_HNSP_enriched_papers_enrichR.csv",
            sep = ",",row.names = FALSE,col.names = TRUE)
plotEnrich(enriched[[4]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")



cat("\n7. RECOMMENDATIONS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Validate top biomarker genes in independent cohorts\n")
cat("- Investigate biological pathways of important genes\n")
cat("- Consider ensemble methods for improved performance\n")
cat("- Perform functional enrichment analysis of top genes\n")

cat("\n", paste(rep("=", 80), collapse = ""), "\n")
```

## Tibia
# tibia adipocyte sclerotic vs non sclerotic RF.
```{r,fig.height=5, fig.width=6}
library(randomForest)
library(heatmaply)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(pheatmap)
library(corrplot)
library(pROC)
#library(caret)
library(VIM)
library(ROCR)
library(plotly)
library(viridis)
library(gridExtra)

# ================================================================
# DATA PREPARATION
# ================================================================

# Prepare the data - top DEG genes
tibia_adipocytes_sclerotic_vs_non_sclerotic_heatmap <- tibia_adipocytes_sclerotic_vs_non_sclerotic$results$table |>
  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns")) |>
  filter(genes != "") |>
  arrange(FDR) |>
  slice_head(n = 500) # Top 500 DEG genes

# Get most variable genes (top 1k)
gene_vars <- apply(tibia_adipocytes_sclerotic_vs_non_sclerotic$normalized_matrix, 1, var, na.rm = TRUE)
top_var_genes <- names(sort(gene_vars, decreasing = TRUE)[1:1000])

# Combine approaches - union of variable and significant genes
selected_genes <- union(top_var_genes, tibia_adipocytes_sclerotic_vs_non_sclerotic_heatmap$genes)

cat("Selected genes:", length(selected_genes), "\n")
cat("Top variable genes:", length(top_var_genes), "\n")
cat("Top DEG genes:", length(tibia_adipocytes_sclerotic_vs_non_sclerotic_heatmap$genes), "\n")

# Prepare normalized counts matrix
norm_counts <- tibia_adipocytes_sclerotic_vs_non_sclerotic$normalized_matrix[selected_genes,]
norm_counts <- na.omit(norm_counts)

cat("Matrix dimensions after filtering:", dim(norm_counts), "\n")


# ================================================================
# SAMPLE ANNOTATION AND METADATA PREPARATION
# ================================================================

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# Add metadata (BMI, Age, Gender)
annotation_col <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

# Combine data
combined_data <- cbind(t(norm_counts), annotation_col)

# Clean data
combined_data <- na.omit(combined_data)
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
combined_data$condition <- as.factor(combined_data$condition)

cat("Final combined data dimensions:", dim(combined_data), "\n")

# ================================================================
# TRAIN-TEST SPLIT (Patient-wise to avoid data leakage)
# ================================================================

# Patient-wise splitting
samples_per_patient <- table(md_df$sample_number)
paired_patients <- names(samples_per_patient)[samples_per_patient == 4]

set.seed(123)
train_proportion <- 0.7
n_train_patients <- round(length(paired_patients) * train_proportion)

train_patient_ids <- sample(paired_patients, n_train_patients)
test_patient_ids <- setdiff(paired_patients, train_patient_ids)

# Create train/test datasets
train_data <- combined_data[md_df$sample_number %in% train_patient_ids,]
test_data <- combined_data[md_df$sample_number %in% test_patient_ids,]

train_data_clean <- train_data[rowSums(is.na(train_data)) != ncol(train_data), ]
test_data_clean <- test_data[rowSums(is.na(test_data)) != ncol(test_data), ]

cat("Training samples:", nrow(train_data_clean), "\n")
cat("Test samples:", nrow(test_data_clean), "\n")
cat("Training patients:", length(train_patient_ids), "\n")
cat("Test patients:", length(test_patient_ids), "\n")

# Check condition distribution
cat("\nTraining set condition distribution:\n")
print(table(train_data_clean$condition))
cat("\nTest set condition distribution:\n")
print(table(test_data_clean$condition))

# ================================================================
# VISUALIZATION 1: DATA OVERVIEW AND QUALITY CHECK
# ================================================================

# Plot 1: Sample distribution
p1 <- ggplot(combined_data, aes(x = condition, fill = condition)) +
  geom_bar(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Sample Distribution by Condition",
       x = "Condition", y = "Number of Samples") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 2: Age distribution by condition
p2 <- ggplot(combined_data, aes(x = condition, y = Age, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Age Distribution by Condition",
       x = "Condition", y = "Age") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 3: BMI distribution by condition
p3 <- ggplot(combined_data, aes(x = condition, y = BMI, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "BMI Distribution by Condition",
       x = "Condition", y = "BMI") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 4: Gender distribution
p4 <- ggplot(combined_data, aes(x = condition, fill = Gender)) +
  geom_bar(position = "dodge", alpha = 0.7) +
  scale_fill_brewer(palette = "Dark2") +
  labs(title = "Gender Distribution by Condition",
       x = "Condition", y = "Count") +
  theme_minimal()

grid.arrange(p1, p2, p3, p4, ncol = 2, nrow = 2)

# Visu
train_data_clean[,c((ncol(train_data_clean)-5):ncol(train_data_clean))]

# ================================================================
# RANDOM FOREST MODEL TRAINING
# ================================================================
# Train Random Forest model with more detailed parameters

rf_model <- randomForest(formula = condition ~ .,
                         data = train_data_clean,
                         importance = TRUE,
                         ntree = 9*ncol(train_data_clean),
                         mtry = sqrt(ncol(train_data_clean)-4), # Approximately sqrt of features
                         do.trace = 100,
                         proximity = TRUE,
                         keep.forest = TRUE
                         )

print(rf_model)

# ================================================================
# VISUALIZATION 2: MODEL PERFORMANCE METRICS
# ================================================================

# Predictions
train_predictions <- predict(rf_model, train_data_clean, type = "response")
test_predictions <- predict(rf_model, test_data_clean, type = "response")

train_probs <- predict(rf_model, train_data_clean, type = "prob")
test_probs <- predict(rf_model, test_data_clean, type = "prob")

# Confusion Matrices
train_cm <- caret::confusionMatrix(train_predictions, train_data_clean$condition)
test_cm <- caret::confusionMatrix(test_predictions, test_data_clean$condition)

print("Training Set Performance:")
print(train_cm)
print("\nTest Set Performance:")
print(test_cm)

# Plot 5: Confusion Matrix Heatmaps
train_cm_df <- as.data.frame(train_cm$table)
test_cm_df <- as.data.frame(test_cm$table)

p5 <- ggplot(train_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Training Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

p6 <- ggplot(test_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Test Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

grid.arrange(p5, p6, ncol = 2)

# ================================================================
# VISUALIZATION 3: ROC CURVES AND AUC
# ================================================================

# ROC Analysis
if(ncol(train_probs) >= 2) {
  # Training ROC
  train_roc <- roc(train_data_clean$condition, train_probs[,2])
  test_roc <- roc(test_data_clean$condition, test_probs[,2])
  
  # Plot ROC curves
  plot(train_roc, main = "ROC Curves Comparison", 
       col = "blue", lwd = 2)
  plot(test_roc, add = TRUE, col = "red", lwd = 2)
  legend("bottomright", 
         legend = c(paste("Training AUC =", round(train_roc$auc, 3)),
                   paste("Test AUC =", round(test_roc$auc, 3))),
         col = c("blue", "red"), lwd = 2)
  
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

# ================================================================
# VISUALIZATION 4: VARIABLE IMPORTANCE
# ================================================================

# Get importance measures
importance_df <- data.frame(
  Gene = rownames(rf_model$importance),
  MeanDecreaseAccuracy = rf_model$importance[,3],
  MeanDecreaseGini = rf_model$importance[,4]
) |>
  arrange(desc(MeanDecreaseAccuracy))

# Plot 7: Top 20 Important Features - Mean Decrease Accuracy
p7 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Accuracy)",
       x = "Genes", y = "Mean Decrease Accuracy") +
  theme_minimal()

# Plot 8: Top 20 Important Features - Mean Decrease Gini
p8 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_col(fill = "darkgreen", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Gini)",
       x = "Genes", y = "Mean Decrease Gini") +
  theme_minimal()

grid.arrange(p7, p8, ncol = 1)

# Plot importance using randomForest's built-in function
varImpPlot(rf_model, main = "Variable Importance Plot")

# ================================================================
# VISUALIZATION 5: MODEL DIAGNOSTICS
# ================================================================

# Plot 9: Error Rate vs Number of Trees
plot(rf_model, main = "Error Rate vs Number of Trees")
legend("topright", legend = c("OOB", levels(train_data_clean$condition)), 
       col = 1:(length(levels(train_data_clean$condition))+1), lty = 1)

# Plot 10: Out-of-Bag Error Rate
oob_error <- rf_model$err.rate[,1]
p10 <- data.frame(Trees = 1:length(oob_error), OOB_Error = oob_error) |>
  ggplot(aes(x = Trees, y = OOB_Error)) +
  geom_line(color = "red", size = 1) +
  labs(title = "Out-of-Bag Error Rate vs Number of Trees",
       x = "Number of Trees", y = "OOB Error Rate") +
  theme_minimal()

print(p10)

# ================================================================
# VISUALIZATION 6: MULTIDIMENSIONAL SCALING (MDS) PLOT
# ================================================================

# MDS plot using proximity matrix
if(!is.null(rf_model$proximity)) {
  mds_result <- cmdscale(1 - rf_model$proximity, k = 2)
  mds_df <- data.frame(
    MDS1 = mds_result[,1],
    MDS2 = mds_result[,2],
    Condition = train_data_clean$condition,
    Predicted = train_predictions
  )
  
  # Plot 11: MDS plot colored by actual condition
  p11 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Set1") +
    labs(title = "MDS Plot - Colored by Actual Condition",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  # Plot 12: MDS plot colored by predictions
  p12 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Predicted, 
                           shape = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = "MDS Plot - Predictions vs Actual (Shape = Actual)",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  grid.arrange(p11, p12, ncol = 2)
}

# ================================================================
# VISUALIZATION 7: GENE EXPRESSION HEATMAP
# ================================================================

# Create heatmap of top important genes
top_genes <- importance_df$Gene[1:50]  # Top 50 most important genes
valid_genes <- top_genes[top_genes %in% rownames(norm_counts)]
heatmap_data <- norm_counts[valid_genes, ]

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# safety colname 
#annotation_col_rownames_safety_check <- annotation_col$sample_2
# Add metadata (BMI, Age, Gender)
heatmap_annotation <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

rownames(heatmap_annotation) <- colnames(heatmap_data)

# Create heatmap
pheatmap(
  heatmap_data,
  annotation_col = heatmap_annotation,
  scale = "row",
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  show_rownames = TRUE,
  show_colnames = FALSE,
  main = "Heatmap of Top 50 Most Important Genes",
  fontsize_row = 6,
  color = colorRampPalette(c("blue", "white", "red"))(100)
)

# ================================================================
# VISUALIZATION 8: PARTIAL DEPENDENCE PLOTS
# ================================================================

# Partial dependence plots for top 6 genes
top_6_genes <- importance_df$Gene[1:6]

par(mfrow = c(2, 3))
for(gene in top_6_genes) {
  partialPlot(rf_model, train_data_clean, x.var = paste0(gene), main = paste("Partial Dependence:", gene))
}
par(mfrow = c(1, 1))

# ================================================================
# COMPREHENSIVE MODEL SUMMARY AND INTERPRETATION
# ================================================================


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("COMPREHENSIVE RANDOM FOREST MODEL ANALYSIS SUMMARY\n")
cat("\n", paste(rep("=", 80), collapse = ""), "\n")

cat("\n1. DATA OVERVIEW:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Total samples:", nrow(combined_data), "\n")
cat("- Total features (genes):", ncol(combined_data) - 4, "\n")
cat("- Training samples:", nrow(train_data_clean), "\n")
cat("- Test samples:", nrow(test_data_clean), "\n")
cat("- Class distribution (overall):", table(combined_data$condition), "\n")

cat("\n2. MODEL CONFIGURATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Number of trees:", rf_model$ntree, "\n")
cat("- Features per split (mtry):", rf_model$mtry, "\n")
cat("- OOB Error Rate:", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), "%\n")

cat("\n3. PERFORMANCE METRICS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("Training Accuracy:", round(train_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Test Accuracy:", round(test_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Training Sensitivity:", round(train_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Test Sensitivity:", round(test_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Training Specificity:", round(train_cm$byClass['Specificity'] * 100, 2), "%\n")
cat("Test Specificity:", round(test_cm$byClass['Specificity'] * 100, 2), "%\n")

if(exists("train_roc")) {
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

cat("\n4. TOP 10 MOST IMPORTANT GENES:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
for(i in 1:10) {
  cat(sprintf("%2d. %s (MDA: %.4f, MDG: %.4f)\n", 
              i, importance_df$Gene[i], 
              importance_df$MeanDecreaseAccuracy[i],
              importance_df$MeanDecreaseGini[i]))
}

cat("\n5. MODEL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- The Random Forest model shows", 
    ifelse(test_cm$overall['Accuracy'] > 0.8, "excellent", 
           ifelse(test_cm$overall['Accuracy'] > 0.7, "good", "moderate")), 
    "predictive performance\n")

cat("- OOB error of", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), 
    "% indicates", 
    ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.1, "excellent", 
           ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.2, "good", "moderate")),
    "model generalization\n")

if(exists("test_roc")) {
  cat("- AUC of", round(test_roc$auc, 3), "suggests", 
      ifelse(test_roc$auc > 0.9, "excellent", 
             ifelse(test_roc$auc > 0.8, "good", "fair")), 
      "discriminative ability\n")
}

cat("- The top important genes likely represent key biomarkers\n")
cat("  distinguishing sclerotic from non-sclerotic conditions\n")

cat("\n6. BIOLOGICAL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Gene expression patterns successfully differentiate conditions\n")
cat("- Important genes may be involved in:\n")
# cat("  * Bone remodeling and sclerosis pathways\n")
# cat("  * Inflammatory responses\n")
# cat("  * Extracellular matrix regulation\n")
# cat("  * Adipocyte differentiation and function\n")
# Add enrichR results top 3 pathwas gobp, kegg and reactome.
# Perform enrichR
#install.packages("enrichR")
library(enrichR)
websiteLive <- getOption("enrichR.live")
if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr") # Human genes   
}
if (websiteLive) dbs <- listEnrichrDbs()
#dbs <- listEnrichrDbs()
dbs

#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> dplyr::filter(FDR < 0.05)
tibia_adipocytes_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05)


message(paste0("Working on sample: ",tibia_adipocytes_sclerotic_vs_non_sclerotic$name))

dbs <- c('GO_Cellular_Component_2017','GO_Molecular_Function_2017','GO_Biological_Process_2017','CellMarker_2024')
enriched <- enrichr(genes = c(tibia_adipocytes_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05) |> 
                      #dplyr::filter(!grepl(x = genes,pattern = "^Gm\\d+")) |>
                      #dplyr::filter(!grepl(x = genes,pattern = "*Rik$")) |> 
                      dplyr::filter(!is.na(genes)) |> 
                      dplyr::filter(genes != "") |>
                      dplyr::filter(!grepl(x = genes, pattern = "ENSG")) |>
                      dplyr::pull(genes)), databases = dbs)

enriched

enriched[["CellMarker_2024"]]
# plot the enrichment 3 from dbs GOBP

#enriched
#enriched$CellMarker_2024
write.table(enriched[["CellMarker_2024"]],file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/tibia_patient/TSA_vs_TNSA_enriched_papers_enrichR.csv",
            sep = ",",row.names = FALSE,col.names = TRUE)
plotEnrich(enriched[[4]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")



cat("\n7. RECOMMENDATIONS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Validate top biomarker genes in independent cohorts\n")
cat("- Investigate biological pathways of important genes\n")
cat("- Consider ensemble methods for improved performance\n")
cat("- Perform functional enrichment analysis of top genes\n")

cat("\n", paste(rep("=", 80), collapse = ""), "\n")
```


# Tibia pellet sclerotic vs non sclerotic rf
```{r,fig.height=5, fig.width=6}
library(randomForest)
library(heatmaply)
library(dplyr)
library(RColorBrewer)
library(ggplot2)
library(pheatmap)
library(corrplot)
library(pROC)
#library(caret)
library(VIM)
library(ROCR)
library(plotly)
library(viridis)
library(gridExtra)

# ================================================================
# DATA PREPARATION
# ================================================================

# Prepare the data - top DEG genes
tibia_pellet_sclerotic_vs_non_sclerotic_heatmap <- tibia_pellet_sclerotic_vs_non_sclerotic$results$table |>
  mutate(gene_type = case_when(
    logFC >= 1 & FDR < 0.05 ~ "up",
    logFC <= -1 & FDR < 0.05 ~ "down",
    TRUE ~ "ns")) |>
  filter(genes != "") |>
  arrange(FDR) |>
  slice_head(n = 500) # Top 500 DEG genes

# Get most variable genes (top 1k)
gene_vars <- apply(tibia_pellet_sclerotic_vs_non_sclerotic$normalized_matrix, 1, var, na.rm = TRUE)
top_var_genes <- names(sort(gene_vars, decreasing = TRUE)[1:1000])

# Combine approaches - union of variable and significant genes
selected_genes <- union(top_var_genes, tibia_pellet_sclerotic_vs_non_sclerotic_heatmap$genes)

cat("Selected genes:", length(selected_genes), "\n")
cat("Top variable genes:", length(top_var_genes), "\n")
cat("Top DEG genes:", length(tibia_pellet_sclerotic_vs_non_sclerotic_heatmap$genes), "\n")

# Prepare normalized counts matrix
norm_counts <- tibia_pellet_sclerotic_vs_non_sclerotic$normalized_matrix[selected_genes,]
norm_counts <- na.omit(norm_counts)

cat("Matrix dimensions after filtering:", dim(norm_counts), "\n")


# ================================================================
# SAMPLE ANNOTATION AND METADATA PREPARATION
# ================================================================

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# Add metadata (BMI, Age, Gender)
annotation_col <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

# Combine data
combined_data <- cbind(t(norm_counts), annotation_col)

# Clean data
combined_data <- na.omit(combined_data)
colnames(combined_data) <- gsub("-", ".", colnames(combined_data))
combined_data$condition <- as.factor(combined_data$condition)

cat("Final combined data dimensions:", dim(combined_data), "\n")

# ================================================================
# TRAIN-TEST SPLIT (Patient-wise to avoid data leakage)
# ================================================================

# Patient-wise splitting
samples_per_patient <- table(md_df$sample_number)
paired_patients <- names(samples_per_patient)[samples_per_patient == 4]

set.seed(123)
train_proportion <- 0.7
n_train_patients <- round(length(paired_patients) * train_proportion)

train_patient_ids <- sample(paired_patients, n_train_patients)
test_patient_ids <- setdiff(paired_patients, train_patient_ids)

# Create train/test datasets
train_data <- combined_data[md_df$sample_number %in% train_patient_ids,]
test_data <- combined_data[md_df$sample_number %in% test_patient_ids,]

train_data_clean <- train_data[rowSums(is.na(train_data)) != ncol(train_data), ]
test_data_clean <- test_data[rowSums(is.na(test_data)) != ncol(test_data), ]

cat("Training samples:", nrow(train_data_clean), "\n")
cat("Test samples:", nrow(test_data_clean), "\n")
cat("Training patients:", length(train_patient_ids), "\n")
cat("Test patients:", length(test_patient_ids), "\n")

# Check condition distribution
cat("\nTraining set condition distribution:\n")
print(table(train_data_clean$condition))
cat("\nTest set condition distribution:\n")
print(table(test_data_clean$condition))

# ================================================================
# VISUALIZATION 1: DATA OVERVIEW AND QUALITY CHECK
# ================================================================

# Plot 1: Sample distribution
p1 <- ggplot(combined_data, aes(x = condition, fill = condition)) +
  geom_bar(alpha = 0.7) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Sample Distribution by Condition",
       x = "Condition", y = "Number of Samples") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 2: Age distribution by condition
p2 <- ggplot(combined_data, aes(x = condition, y = Age, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Age Distribution by Condition",
       x = "Condition", y = "Age") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 3: BMI distribution by condition
p3 <- ggplot(combined_data, aes(x = condition, y = BMI, fill = condition)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "BMI Distribution by Condition",
       x = "Condition", y = "BMI") +
  theme_minimal() +
  theme(legend.position = "none")

# Plot 4: Gender distribution
p4 <- ggplot(combined_data, aes(x = condition, fill = Gender)) +
  geom_bar(position = "dodge", alpha = 0.7) +
  scale_fill_brewer(palette = "Dark2") +
  labs(title = "Gender Distribution by Condition",
       x = "Condition", y = "Count") +
  theme_minimal()

grid.arrange(p1, p2, p3, p4, ncol = 2, nrow = 2)

# Visu
train_data_clean[,c((ncol(train_data_clean)-5):ncol(train_data_clean))]

# ================================================================
# RANDOM FOREST MODEL TRAINING
# ================================================================
# Train Random Forest model with more detailed parameters

rf_model <- randomForest(formula = condition ~ .,
                         data = train_data_clean,
                         importance = TRUE,
                         ntree = 9*ncol(train_data_clean),
                         mtry = sqrt(ncol(train_data_clean)-4), # Approximately sqrt of features
                         do.trace = 100,
                         proximity = TRUE,
                         keep.forest = TRUE
                         )

print(rf_model)

# ================================================================
# VISUALIZATION 2: MODEL PERFORMANCE METRICS
# ================================================================

# Predictions
train_predictions <- predict(rf_model, train_data_clean, type = "response")
test_predictions <- predict(rf_model, test_data_clean, type = "response")

train_probs <- predict(rf_model, train_data_clean, type = "prob")
test_probs <- predict(rf_model, test_data_clean, type = "prob")

# Confusion Matrices
train_cm <- caret::confusionMatrix(train_predictions, train_data_clean$condition)
test_cm <- caret::confusionMatrix(test_predictions, test_data_clean$condition)

print("Training Set Performance:")
print(train_cm)
print("\nTest Set Performance:")
print(test_cm)

# Plot 5: Confusion Matrix Heatmaps
train_cm_df <- as.data.frame(train_cm$table)
test_cm_df <- as.data.frame(test_cm$table)

p5 <- ggplot(train_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Training Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

p6 <- ggplot(test_cm_df, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = Freq), color = "white", size = 6) +
  scale_fill_viridis_c() +
  labs(title = "Test Set Confusion Matrix",
       x = "Actual", y = "Predicted") +
  theme_minimal()

grid.arrange(p5, p6, ncol = 2)

# ================================================================
# VISUALIZATION 3: ROC CURVES AND AUC
# ================================================================

# ROC Analysis
if(ncol(train_probs) >= 2) {
  # Training ROC
  train_roc <- roc(train_data_clean$condition, train_probs[,2])
  test_roc <- roc(test_data_clean$condition, test_probs[,2])
  
  # Plot ROC curves
  plot(train_roc, main = "ROC Curves Comparison", 
       col = "blue", lwd = 2)
  plot(test_roc, add = TRUE, col = "red", lwd = 2)
  legend("bottomright", 
         legend = c(paste("Training AUC =", round(train_roc$auc, 3)),
                   paste("Test AUC =", round(test_roc$auc, 3))),
         col = c("blue", "red"), lwd = 2)
  
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

# ================================================================
# VISUALIZATION 4: VARIABLE IMPORTANCE
# ================================================================

# Get importance measures
importance_df <- data.frame(
  Gene = rownames(rf_model$importance),
  MeanDecreaseAccuracy = rf_model$importance[,3],
  MeanDecreaseGini = rf_model$importance[,4]
) |>
  arrange(desc(MeanDecreaseAccuracy))

# Plot 7: Top 20 Important Features - Mean Decrease Accuracy
p7 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseAccuracy), y = MeanDecreaseAccuracy)) +
  geom_col(fill = "steelblue", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Accuracy)",
       x = "Genes", y = "Mean Decrease Accuracy") +
  theme_minimal()

# Plot 8: Top 20 Important Features - Mean Decrease Gini
p8 <- importance_df |>
  slice_head(n = 20) |>
  ggplot(aes(x = reorder(Gene, MeanDecreaseGini), y = MeanDecreaseGini)) +
  geom_col(fill = "darkgreen", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 20 Most Important Genes (Mean Decrease Gini)",
       x = "Genes", y = "Mean Decrease Gini") +
  theme_minimal()

grid.arrange(p7, p8, ncol = 1)

# Plot importance using randomForest's built-in function
varImpPlot(rf_model, main = "Variable Importance Plot")

# ================================================================
# VISUALIZATION 5: MODEL DIAGNOSTICS
# ================================================================

# Plot 9: Error Rate vs Number of Trees
plot(rf_model, main = "Error Rate vs Number of Trees")
legend("topright", legend = c("OOB", levels(train_data_clean$condition)), 
       col = 1:(length(levels(train_data_clean$condition))+1), lty = 1)

# Plot 10: Out-of-Bag Error Rate
oob_error <- rf_model$err.rate[,1]
p10 <- data.frame(Trees = 1:length(oob_error), OOB_Error = oob_error) |>
  ggplot(aes(x = Trees, y = OOB_Error)) +
  geom_line(color = "red", size = 1) +
  labs(title = "Out-of-Bag Error Rate vs Number of Trees",
       x = "Number of Trees", y = "OOB Error Rate") +
  theme_minimal()

print(p10)

# ================================================================
# VISUALIZATION 6: MULTIDIMENSIONAL SCALING (MDS) PLOT
# ================================================================

# MDS plot using proximity matrix
if(!is.null(rf_model$proximity)) {
  mds_result <- cmdscale(1 - rf_model$proximity, k = 2)
  mds_df <- data.frame(
    MDS1 = mds_result[,1],
    MDS2 = mds_result[,2],
    Condition = train_data_clean$condition,
    Predicted = train_predictions
  )
  
  # Plot 11: MDS plot colored by actual condition
  p11 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Set1") +
    labs(title = "MDS Plot - Colored by Actual Condition",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  # Plot 12: MDS plot colored by predictions
  p12 <- ggplot(mds_df, aes(x = MDS1, y = MDS2, color = Predicted, 
                           shape = Condition)) +
    geom_point(size = 3, alpha = 0.7) +
    scale_color_brewer(palette = "Dark2") +
    labs(title = "MDS Plot - Predictions vs Actual (Shape = Actual)",
         x = "MDS Dimension 1", y = "MDS Dimension 2") +
    theme_minimal()
  
  grid.arrange(p11, p12, ncol = 2)
}

# ================================================================
# VISUALIZATION 7: GENE EXPRESSION HEATMAP
# ================================================================

# Create heatmap of top important genes
top_genes <- importance_df$Gene[1:50]  # Top 50 most important genes
valid_genes <- top_genes[top_genes %in% rownames(norm_counts)]
heatmap_data <- norm_counts[valid_genes, ]

# Prepare annotation data
annotation_col <- as.data.frame(colnames(norm_counts))
colnames(annotation_col) <- "sample"
annotation_col$sample_2 <- annotation_col$sample

# Split sample names
annotation_col <- annotation_col |> 
  separate(sample, into = c("ID", "tissue", "condition", "type"), sep = "_")

# safety colname 
#annotation_col_rownames_safety_check <- annotation_col$sample_2
# Add metadata (BMI, Age, Gender)
heatmap_annotation <- annotation_col |> 
  left_join(md_df[,c("sampleID","Age","Gender","BMI")], by = c("sample_2"="sampleID")) |>
  select(-ID, -tissue, -type, -sample_2)

rownames(heatmap_annotation) <- colnames(heatmap_data)

# Create heatmap
pheatmap(
  heatmap_data,
  annotation_col = heatmap_annotation,
  scale = "row",
  clustering_distance_rows = "correlation",
  clustering_distance_cols = "correlation",
  show_rownames = TRUE,
  show_colnames = FALSE,
  main = "Heatmap of Top 50 Most Important Genes",
  fontsize_row = 6,
  color = colorRampPalette(c("blue", "white", "red"))(100)
)

# ================================================================
# VISUALIZATION 8: PARTIAL DEPENDENCE PLOTS
# ================================================================

# Partial dependence plots for top 6 genes
top_6_genes <- importance_df$Gene[1:6]

par(mfrow = c(2, 3))
for(gene in top_6_genes) {
  partialPlot(rf_model, train_data_clean, x.var = paste(gene), main = paste("Partial Dependence:", gene))
}
par(mfrow = c(1, 1))

# ================================================================
# COMPREHENSIVE MODEL SUMMARY AND INTERPRETATION
# ================================================================


cat("\n", paste(rep("=", 80), collapse = ""), "\n")
cat("COMPREHENSIVE RANDOM FOREST MODEL ANALYSIS SUMMARY\n")
cat("\n", paste(rep("=", 80), collapse = ""), "\n")

cat("\n1. DATA OVERVIEW:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Total samples:", nrow(combined_data), "\n")
cat("- Total features (genes):", ncol(combined_data) - 4, "\n")
cat("- Training samples:", nrow(train_data_clean), "\n")
cat("- Test samples:", nrow(test_data_clean), "\n")
cat("- Class distribution (overall):", table(combined_data$condition), "\n")

cat("\n2. MODEL CONFIGURATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Number of trees:", rf_model$ntree, "\n")
cat("- Features per split (mtry):", rf_model$mtry, "\n")
cat("- OOB Error Rate:", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), "%\n")

cat("\n3. PERFORMANCE METRICS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("Training Accuracy:", round(train_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Test Accuracy:", round(test_cm$overall['Accuracy'] * 100, 2), "%\n")
cat("Training Sensitivity:", round(train_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Test Sensitivity:", round(test_cm$byClass['Sensitivity'] * 100, 2), "%\n")
cat("Training Specificity:", round(train_cm$byClass['Specificity'] * 100, 2), "%\n")
cat("Test Specificity:", round(test_cm$byClass['Specificity'] * 100, 2), "%\n")

if(exists("train_roc")) {
  cat("Training AUC:", round(train_roc$auc, 3), "\n")
  cat("Test AUC:", round(test_roc$auc, 3), "\n")
}

cat("\n4. TOP 10 MOST IMPORTANT GENES:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
for(i in 1:10) {
  cat(sprintf("%2d. %s (MDA: %.4f, MDG: %.4f)\n", 
              i, importance_df$Gene[i], 
              importance_df$MeanDecreaseAccuracy[i],
              importance_df$MeanDecreaseGini[i]))
}

cat("\n5. MODEL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- The Random Forest model shows", 
    ifelse(test_cm$overall['Accuracy'] > 0.8, "excellent", 
           ifelse(test_cm$overall['Accuracy'] > 0.7, "good", "moderate")), 
    "predictive performance\n")

cat("- OOB error of", round(rf_model$err.rate[rf_model$ntree, 1] * 100, 2), 
    "% indicates", 
    ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.1, "excellent", 
           ifelse(rf_model$err.rate[rf_model$ntree, 1] < 0.2, "good", "moderate")),
    "model generalization\n")

if(exists("test_roc")) {
  cat("- AUC of", round(test_roc$auc, 3), "suggests", 
      ifelse(test_roc$auc > 0.9, "excellent", 
             ifelse(test_roc$auc > 0.8, "good", "fair")), 
      "discriminative ability\n")
}

cat("- The top important genes likely represent key biomarkers\n")
cat("  distinguishing sclerotic from non-sclerotic conditions\n")

cat("\n6. BIOLOGICAL INTERPRETATION:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Gene expression patterns successfully differentiate conditions\n")
cat("- Important genes may be involved in:\n")
# cat("  * Bone remodeling and sclerosis pathways\n")
# cat("  * Inflammatory responses\n")
# cat("  * Extracellular matrix regulation\n")
# cat("  * Adipocyte differentiation and function\n")
# Add enrichR results top 3 pathwas gobp, kegg and reactome.
# Perform enrichR
#install.packages("enrichR")
library(enrichR)
websiteLive <- getOption("enrichR.live")
if (websiteLive) {
    listEnrichrSites()
    setEnrichrSite("Enrichr") # Human genes   
}
if (websiteLive) dbs <- listEnrichrDbs()
#dbs <- listEnrichrDbs()
dbs

#pellets_hip_and_tibia_sclerotic_vs_non_sclerotic[[1]]$results$table |> dplyr::filter(FDR < 0.05)
tibia_pellet_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05)


message(paste0("Working on sample: ",tibia_pellet_sclerotic_vs_non_sclerotic$name))

dbs <- c('GO_Cellular_Component_2017','GO_Molecular_Function_2017','GO_Biological_Process_2017','CellMarker_2024')
enriched <- enrichr(genes = c(tibia_pellet_sclerotic_vs_non_sclerotic$results$table |> dplyr::filter(FDR < 0.05) |> 
                      #dplyr::filter(!grepl(x = genes,pattern = "^Gm\\d+")) |>
                      #dplyr::filter(!grepl(x = genes,pattern = "*Rik$")) |> 
                      dplyr::filter(!is.na(genes)) |> 
                      dplyr::filter(genes != "") |>
                      dplyr::filter(!grepl(x = genes, pattern = "ENSG")) |>
                      dplyr::pull(genes)), databases = dbs)

enriched

enriched[["CellMarker_2024"]]
# plot the enrichment 3 from dbs GOBP

#enriched
#enriched$CellMarker_2024
write.table(enriched[["CellMarker_2024"]],file = "~/CLUSTER/Environments/2024_07_05_Lea_Lausanne_Hip_Tibia_BRBseq/Analysis_removed_samples_2/DGE_Results_tables/tibia_patient/TSP_vs_TNSP_enriched_papers_enrichR.csv",
            sep = ",",row.names = FALSE,col.names = TRUE)
plotEnrich(enriched[[4]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")



cat("\n7. RECOMMENDATIONS:\n")
cat("\n", paste(rep("-", 50), collapse = ""), "\n")
cat("- Validate top biomarker genes in independent cohorts\n")
cat("- Investigate biological pathways of important genes\n")
cat("- Consider ensemble methods for improved performance\n")
cat("- Perform functional enrichment analysis of top genes\n")

cat("\n", paste(rep("=", 80), collapse = ""), "\n")
```




# TODO correlate if other ML models agree, add OARSI model and predict sclerotic and non-sclerotic, and get predictive genes, end!

# Train model
```{r}
```

# Use data
```{r}
```

# Get results
```{r}
```


```{r}
```


```{r}
```


```{r}
```























```{r}

```


```{r}
#################
### Cancer dataset
#################

library(mlbench)
data(BreastCancer)
head(BreastCancer)


bc.df=BreastCancer
class(bc.df)

set.seed(123)

#import dataset, rename labels

bc.df$Class = as.factor(bc.df$Class)
bc.df = dplyr::rename(bc.df,labels = Class)

bc.df[1:10] <- sapply(bc.df[1:10], as.numeric)

bc.df=bc.df[2:11]

trn_indx <- createDataPartition(bc.df$labels ,
                                p = .7, list = FALSE,times = 1) %>% as.numeric()
tst_indx <- which(!(seq_len(nrow(bc.df)) %in% trn_indx))
train = bc.df[trn_indx,]
test = bc.df[tst_indx,]

#?preProcess
#Pre-prrocess the train Dataset
preprocTrain <- preProcess(train,
                           method=c("center","scale", "medianImpute"))
pp_train <- predict(preprocTrain, train)

##Pre-process the test Dataset
preprocTest <- preProcess(test,method=c("center","scale", "medianImpute"))
pp_test <- predict(preprocTest, test)

###rpart
set.seed(123)
rpart = caret::train(labels~ .,
                     data=pp_train,
                     method = 'rpart')

pred = predict(rpart,pp_test,type="raw")
pred.in.sample = predict(rpart,pp_train,type="raw")
mean(pred != pp_test$labels)
mean(pred.in.sample != pp_train$labels)

cMatrixRpart=confusionMatrix(pred,pp_test$labels)

plt <- as.data.frame(cMatrixRpart$table)
ggplot(plt, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference")

###v random forest
tunegrid <- expand.grid(
  mtry = c(1:6)
)
trcontrol <- trainControl(method = "repeatedcv",
                          number = 5,
                          repeats = 1,
                          search = "grid")

rf_train = caret::train(labels~ .,
                        data=pp_train,
                        trControl = trcontrol,
                        tuneGrid = tunegrid,
                        method = 'parRF')

pred = predict(rf_train,pp_test,type="raw")
pred.in.sample = predict(rf_train,pp_train,type="raw")
mean(pred != pp_test$labels)
mean(pred.in.sample != pp_train$labels)

cMatrixRF=confusionMatrix(pred,pp_test$labels)

plt <- as.data.frame(cMatrixRF$table)
ggplot(plt, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference")

roc_imp2 <- varImp(rf_train,
                   scale = FALSE)
plot(roc_imp2,
     top=5,xlim=c(0,max(roc_imp2$importance)))


##XGboost
tunegrid <- expand.grid(nrounds = seq(1,100,by=20),
                        max_depth = c(1,5,10),
                        eta = seq(0.01,0.5,length.out = 5),
                        gamma = 1,
                        colsample_bytree = 1,
                        min_child_weight = 1,
                        subsample = 1)

trcontrol <- trainControl(method = "repeatedcv",
                          number = 5,
                          repeats = 5,
                          search = "random",
                          savePredictions = T)


set.seed(123)
xgb_train = train(labels~ .,
                  data=pp_train,
                  trControl = trcontrol,
                  tuneGrid = tunegrid,
                  method = "xgbTree")

plot(xgb_train)

pred = predict(xgb_train,pp_test,type="raw")
pred.in.sample = predict(xgb_train,pp_train,type="raw")
mean(pred != pp_test$labels)
mean(pred.in.sample != pp_train$labels)

cMatrixXGB=confusionMatrix(pred,pp_test$labels)

cMatrix$byClass

confusionMatrix
#cMatrix=confusionMatrix(xgb_train)

plt <- as.data.frame(cMatrixXGB$table)
ggplot(plt, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference")

roc_imp2 <- varImp(xgb_train,
                   scale = FALSE)
plot(roc_imp2,
     top=5,xlim=c(0,max(roc_imp2$importance)))


####Neural network

trcontrol <- trainControl(
  method = "cv",
  number = 20,
  classProbs = TRUE)

tune_grid <- expand.grid(
  size = (3:8),
  decay = c(0.01,0.1,0.2))

set.seed(123)
mod_nnet = caret::train(labels~ .,
                        data=pp_train,
                        method = "nnet",
                        trControl = trcontrol,
                        tuneGrid = tune_grid,
                        trace = FALSE)
plot(mod_nnet)


pred = predict(mod_nnet,pp_test,type="raw")
pred.in.sample = predict(mod_nnet,pp_train,type="raw")
mean(pred != pp_test$labels)
mean(pred.in.sample != pp_train$labels)

cMatrixNnet=confusionMatrix(pred,pp_test$labels)
#cMatrix=confusionMatrix(mod_nnet)

plt <- as.data.frame(cMatrixNnet$table)
ggplot(plt, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference")

results=t(cbind(RndFrst=cMatrixRF$overall,Nnet=cMatrixNnet$overall,XGB=cMatrixXGB$overall,Rpart=cMatrixRpart$overall))



pltNnet <- as.data.frame(cMatrixNnet$table)
pltRF <- as.data.frame(cMatrixRF$table)
pltRpart <- as.data.frame(cMatrixRpart$table)
pltXGB <- as.data.frame(cMatrixXGB$table)




a= ggplot(pltNnet, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference", title = "Rpart")
b=ggplot(pltRF, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference", title = "RF")
c=ggplot(pltRpart, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference", title = "XGB")
d=ggplot(pltXGB, aes(Prediction,Reference, fill= Freq)) +
  geom_tile() + geom_text(aes(label=round(Freq))) +
  scale_fill_gradient(low="white", high="#009194") +
  labs(x = "Prediction",y = "Reference", title = "NNet")


grid.arrange(a,b,c,d)
```


```{r}
library(caret)
rf_pred_class <- predict(rf_model, test_data)
confusionMatrix <- confusionMatrix(rf_pred_class, test_data$condition)
fourfoldplot(confusionMatrix$table, color = c("#CC6666", "#99CC99"), conf.level = 0, margin = 1, main = "Confusion Matrix")

```
```{r}
#Explore with more models... ELASTIC NET
```

